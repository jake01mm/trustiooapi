
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>dto: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">trusioo_api/internal/auth/admin_auth/dto/auth.go (0.0%)</option>
				
				<option value="file1">trusioo_api/internal/auth/admin_auth/handler.go (0.0%)</option>
				
				<option value="file2">trusioo_api/internal/auth/admin_auth/repository.go (0.0%)</option>
				
				<option value="file3">trusioo_api/internal/auth/admin_auth/routes.go (0.0%)</option>
				
				<option value="file4">trusioo_api/internal/auth/admin_auth/service.go (0.0%)</option>
				
				<option value="file5">trusioo_api/internal/auth/user_auth/dto/auth.go (50.0%)</option>
				
				<option value="file6">trusioo_api/internal/auth/user_auth/handler.go (0.0%)</option>
				
				<option value="file7">trusioo_api/internal/auth/user_auth/repository.go (0.0%)</option>
				
				<option value="file8">trusioo_api/internal/auth/user_auth/routes.go (0.0%)</option>
				
				<option value="file9">trusioo_api/internal/auth/user_auth/service.go (35.0%)</option>
				
				<option value="file10">trusioo_api/internal/auth/verification/repository.go (0.0%)</option>
				
				<option value="file11">trusioo_api/internal/auth/verification/service.go (0.0%)</option>
				
				<option value="file12">trusioo_api/internal/middleware/auth.go (84.5%)</option>
				
				<option value="file13">trusioo_api/internal/middleware/image.go (0.0%)</option>
				
				<option value="file14">trusioo_api/internal/middleware/ratelimit.go (0.0%)</option>
				
				<option value="file15">trusioo_api/internal/middleware/request_id.go (0.0%)</option>
				
				<option value="file16">trusioo_api/internal/middleware/security.go (0.0%)</option>
				
				<option value="file17">trusioo_api/internal/middleware/validation.go (0.0%)</option>
				
				<option value="file18">trusioo_api/pkg/auth/token.go (84.6%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package dto

import "trusioo_api/internal/auth/admin_auth/entities"

// AdminLoginRequest 管理员登录请求 - 第一步：验证email+password并发送验证码
type AdminLoginRequest struct {
        Email    string `json:"email" binding:"required,email"`
        Password string `json:"password" binding:"required"`
}

// VerificationType 返回管理员登录的验证类型
func (r *AdminLoginRequest) VerificationType() string <span class="cov0" title="0">{
        return "admin_login"
}</span>

// AdminLoginVerifyRequest 管理员登录验证请求 - 第二步：验证登录验证码
// 注意：此请求在Service层会自动添加 type: "admin_login" 字段调用verification服务
type AdminLoginVerifyRequest struct {
        Email string `json:"email" binding:"required,email"`
        Code  string `json:"code" binding:"required,len=6"`
}

// VerificationType 返回此DTO对应的验证类型
func (r *AdminLoginVerifyRequest) VerificationType() string <span class="cov0" title="0">{
        return "admin_login"
}</span>

// AdminLoginCodeResponse 管理员登录验证码响应
type AdminLoginCodeResponse struct {
        Message   string `json:"message"`
        LoginCode string `json:"login_code"`
        ExpiresIn int    `json:"expires_in"` // 秒
}

// AdminLoginResponse 管理员登录响应
type AdminLoginResponse struct {
        AccessToken  string                 `json:"access_token"`
        RefreshToken string                 `json:"refresh_token"`
        ExpiresIn    int64                  `json:"expires_in"`
        TokenType    string                 `json:"token_type"`
        Admin        entities.Admin         `json:"admin"`
        LoginSession *AdminLoginSessionInfo `json:"login_session,omitempty"`
}

// AdminLoginSessionInfo 管理员登录会话信息
type AdminLoginSessionInfo struct {
        IP           string `json:"ip"`
        Country      string `json:"country"`
        City         string `json:"city"`
        Region       string `json:"region"`
        Timezone     string `json:"timezone"`
        Organization string `json:"organization"`
        Location     string `json:"location"`
        IsTrusted    bool   `json:"is_trusted"`
}

// RefreshTokenRequest 刷新令牌请求
type RefreshTokenRequest struct {
        RefreshToken string `json:"refresh_token" binding:"required"`
}

// AdminForgotPasswordRequest 管理员忘记密码请求
type AdminForgotPasswordRequest struct {
        Email string `json:"email" binding:"required,email"`
}

// AdminForgotPasswordResponse 管理员忘记密码响应
type AdminForgotPasswordResponse struct {
        Message   string `json:"message"`
        ExpiresIn int    `json:"expires_in"` // 秒
}

// AdminResetPasswordRequest 管理员重置密码请求
type AdminResetPasswordRequest struct {
        Email    string `json:"email" binding:"required,email"`
        Code     string `json:"code" binding:"required,len=6"`
        Password string `json:"password" binding:"required,min=6"`
}

// AdminResetPasswordResponse 管理员重置密码响应
type AdminResetPasswordResponse struct {
        Message string `json:"message"`
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package admin

import (
        "strconv"

        "trusioo_api/internal/auth/admin_auth/dto"
        "trusioo_api/internal/common"

        "github.com/gin-gonic/gin"
)

type Handler struct {
        service *Service
}

func NewHandler(service *Service) *Handler <span class="cov0" title="0">{
        return &amp;Handler{service: service}
}</span>

// Login 管理员登录第一步
// @Summary 管理员登录第一步
// @Description 验证管理员邮箱和密码，成功后发送登录验证码
// @Tags 管理员
// @Accept json
// @Produce json
// @Param request body AdminLoginRequest true "登录请求参数"
// @Success 200 {object} common.Response{data=dto.AdminLoginCodeResponse} "验证码发送成功"
// @Failure 400 {object} common.Response "参数错误或登录失败"
// @Failure 500 {object} common.Response "服务器错误"
// @Router /api/v1/admin/auth/login [post]
func (h *Handler) Login(c *gin.Context) <span class="cov0" title="0">{
        var req dto.AdminLoginRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                common.ValidationError(c, err.Error())
                return
        }</span>

        <span class="cov0" title="0">clientIP := c.ClientIP()
        userAgent := c.GetHeader("User-Agent")

        resp, err := h.service.Login(&amp;req, clientIP, userAgent)
        if err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case common.ErrAdminNotFound:<span class="cov0" title="0">
                        common.ValidationError(c, "Admin does not exist")</span>
                case common.ErrInvalidAdminCredentials:<span class="cov0" title="0">
                        common.ValidationError(c, "Email or password is incorrect")</span>
                case common.ErrAdminInactive:<span class="cov0" title="0">
                        common.ValidationError(c, "Account not activated")</span>
                default:<span class="cov0" title="0">
                        common.ServerError(c, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">common.Success(c, resp)</span>
}

// LoginVerify 管理员登录第二步
// @Summary 管理员登录第二步
// @Description 验证管理员登录验证码并返回访问令牌
// @Tags 管理员
// @Accept json
// @Produce json
// @Param request body AdminLoginVerifyRequest true "登录验证请求参数"
// @Success 200 {object} common.Response{data=dto.AdminLoginResponse} "登录成功"
// @Failure 400 {object} common.Response "参数错误或验证失败"
// @Failure 500 {object} common.Response "服务器错误"
// @Router /api/v1/admin/auth/login/verify [post]
func (h *Handler) LoginVerify(c *gin.Context) <span class="cov0" title="0">{
        var req dto.AdminLoginVerifyRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                common.ValidationError(c, err.Error())
                return
        }</span>

        <span class="cov0" title="0">clientIP := c.ClientIP()
        userAgent := c.GetHeader("User-Agent")

        resp, err := h.service.LoginVerify(&amp;req, clientIP, userAgent)
        if err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case common.ErrAdminNotFound:<span class="cov0" title="0">
                        common.ValidationError(c, "Admin does not exist")</span>
                case common.ErrInvalidCode:<span class="cov0" title="0">
                        common.ValidationError(c, "Invalid or expired verification code")</span>
                default:<span class="cov0" title="0">
                        common.ServerError(c, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">common.Success(c, resp)</span>
}

// RefreshToken 刷新访问令牌
// @Summary 刷新访问令牌
// @Description 使用刷新令牌获取新的访问令牌
// @Tags 管理员
// @Accept json
// @Produce json
// @Param request body RefreshTokenRequest true "刷新令牌请求参数"
// @Success 200 {object} common.Response{data=dto.AdminLoginResponse} "刷新成功"
// @Failure 400 {object} common.Response "参数错误或令牌无效"
// @Failure 500 {object} common.Response "服务器错误"
// @Router /api/v1/admin/auth/refresh [post]
func (h *Handler) RefreshToken(c *gin.Context) <span class="cov0" title="0">{
        var req dto.RefreshTokenRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                common.ValidationError(c, err.Error())
                return
        }</span>

        <span class="cov0" title="0">resp, err := h.service.RefreshToken(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case common.ErrTokenInvalid, common.ErrRefreshTokenInvalid:<span class="cov0" title="0">
                        common.Unauthorized(c, "Invalid refresh token")</span>
                case common.ErrAdminNotFound:<span class="cov0" title="0">
                        common.ValidationError(c, "Admin not found")</span>
                case common.ErrAdminInactive:<span class="cov0" title="0">
                        common.ValidationError(c, "Account not activated")</span>
                default:<span class="cov0" title="0">
                        common.ServerError(c, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">common.Success(c, resp)</span>
}

// GetProfile 获取管理员资料
// @Summary 获取管理员资料
// @Description 获取当前登录管理员的个人资料
// @Tags 管理员
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Success 200 {object} common.Response{data=entities.Admin} "获取成功"
// @Failure 401 {object} common.Response "未授权"
// @Failure 500 {object} common.Response "服务器错误"
// @Router /api/v1/admin/profile [get]
func (h *Handler) GetProfile(c *gin.Context) <span class="cov0" title="0">{
        adminID, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                common.Unauthorized(c, "Admin not authenticated")
                return
        }</span>

        <span class="cov0" title="0">admin, err := h.service.GetAdminByID(adminID.(int64))
        if err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case common.ErrAdminNotFound:<span class="cov0" title="0">
                        common.NotFound(c, "Admin not found")</span>
                default:<span class="cov0" title="0">
                        common.ServerError(c, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">common.Success(c, admin)</span>
}

// GetUserStats 获取用户统计
// @Summary 获取用户统计
// @Description 获取用户统计数据
// @Tags 管理员-用户管理
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Success 200 {object} common.Response{data=dto.UserStats} "获取成功"
// @Failure 401 {object} common.Response "未授权"
// @Failure 500 {object} common.Response "服务器错误"
// @Router /api/v1/admin/users/stats [get]
func (h *Handler) GetUserStats(c *gin.Context) <span class="cov0" title="0">{
        stats, err := h.service.GetUserStats()
        if err != nil </span><span class="cov0" title="0">{
                common.ServerError(c, err)
                return
        }</span>

        <span class="cov0" title="0">common.Success(c, stats)</span>
}

// GetUserList 获取用户列表
// @Summary 获取用户列表
// @Description 获取用户列表（支持分页和筛选）
// @Tags 管理员-用户管理
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Param page query int false "页码" default(1)
// @Param page_size query int false "每页条数" default(20)
// @Param status query string false "用户状态筛选" Enums(active, inactive, all)
// @Param email query string false "邮箱筛选"
// @Param phone query string false "手机号筛选"
// @Success 200 {object} common.Response{data=dto.UserListResponse} "获取成功"
// @Failure 400 {object} common.Response "参数错误"
// @Failure 401 {object} common.Response "未授权"
// @Failure 500 {object} common.Response "服务器错误"
// @Router /api/v1/admin/users [get]
func (h *Handler) GetUserList(c *gin.Context) <span class="cov0" title="0">{
        var req dto.UserListRequest
        if err := c.ShouldBindQuery(&amp;req); err != nil </span><span class="cov0" title="0">{
                common.ValidationError(c, err.Error())
                return
        }</span>

        <span class="cov0" title="0">resp, err := h.service.GetUserList(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                common.ServerError(c, err)
                return
        }</span>

        <span class="cov0" title="0">common.Success(c, resp)</span>
}

// GetUserDetail 获取用户详情
// @Summary 获取用户详情
// @Description 根据用户ID获取用户详细信息
// @Tags 管理员-用户管理
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Param id path int true "用户ID"
// @Success 200 {object} common.Response{data=entities.UserInfo} "获取成功"
// @Failure 400 {object} common.Response "参数错误"
// @Failure 401 {object} common.Response "未授权"
// @Failure 404 {object} common.Response "用户不存在"
// @Failure 500 {object} common.Response "服务器错误"
// @Router /api/v1/admin/users/{id} [get]
func (h *Handler) GetUserDetail(c *gin.Context) <span class="cov0" title="0">{
        userIDStr := c.Param("id")
        userID, err := strconv.ParseInt(userIDStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                common.ValidationError(c, "Invalid user ID")
                return
        }</span>

        <span class="cov0" title="0">user, err := h.service.GetUserByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case common.ErrUserNotFound:<span class="cov0" title="0">
                        common.NotFound(c, "User not found")</span>
                default:<span class="cov0" title="0">
                        common.ServerError(c, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">common.Success(c, user)</span>
}

// ForgotPassword 管理员忘记密码第一步 - 发送重置密码验证码
// @Summary 管理员忘记密码第一步
// @Description 发送重置密码验证码到管理员邮箱
// @Tags 管理员
// @Accept json
// @Produce json
// @Param request body AdminForgotPasswordRequest true "忘记密码请求参数"
// @Success 200 {object} common.Response{data=dto.AdminForgotPasswordResponse} "验证码发送成功"
// @Failure 400 {object} common.Response "参数错误"
// @Failure 500 {object} common.Response "服务器错误"
// @Router /api/v1/admin/auth/forgot-password [post]
func (h *Handler) ForgotPassword(c *gin.Context) <span class="cov0" title="0">{
        var req dto.AdminForgotPasswordRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                common.ValidationError(c, err.Error())
                return
        }</span>

        <span class="cov0" title="0">resp, err := h.service.ForgotPassword(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                common.ServerError(c, err)
                return
        }</span>

        <span class="cov0" title="0">common.Success(c, resp)</span>
}

// ResetPassword 管理员忘记密码第二步 - 验证验证码并重置密码
// @Summary 管理员忘记密码第二步
// @Description 验证重置密码验证码并设置新密码
// @Tags 管理员
// @Accept json
// @Produce json
// @Param request body AdminResetPasswordRequest true "重置密码请求参数"
// @Success 200 {object} common.Response{data=dto.AdminResetPasswordResponse} "密码重置成功"
// @Failure 400 {object} common.Response "参数错误或验证失败"
// @Failure 500 {object} common.Response "服务器错误"
// @Router /api/v1/admin/auth/reset-password [post]
func (h *Handler) ResetPassword(c *gin.Context) <span class="cov0" title="0">{
        var req dto.AdminResetPasswordRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                common.ValidationError(c, err.Error())
                return
        }</span>

        <span class="cov0" title="0">resp, err := h.service.ResetPassword(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case common.ErrAdminNotFound:<span class="cov0" title="0">
                        common.ValidationError(c, "Admin not found")</span>
                case common.ErrInvalidCode:<span class="cov0" title="0">
                        common.ValidationError(c, "Invalid or expired verification code")</span>
                default:<span class="cov0" title="0">
                        common.ServerError(c, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">common.Success(c, resp)</span>
}</pre>
		
		<pre class="file" id="file2" style="display: none">package admin

import (
        "database/sql"
        "fmt"

        "trusioo_api/internal/auth/admin_auth/dto"
        "trusioo_api/internal/auth/admin_auth/entities"
        "trusioo_api/pkg/database"
)

// AdminRepository 管理员数据访问接口
type AdminRepository interface {
        // Admin相关
        GetByEmail(email string) (*entities.Admin, error)
        GetByID(id int64) (*entities.Admin, error)
        Create(admin *entities.Admin) error
        Update(admin *entities.Admin) error
        UpdateLastLogin(id int64) error
        UpdatePassword(id int64, password string) error
        UpdateEmailVerified(id int64, verified bool) error

        // RefreshToken相关
        CreateRefreshToken(token *entities.AdminRefreshToken) error
        GetValidRefreshToken(token string) (*entities.AdminRefreshToken, error)
        InvalidateRefreshToken(token string) error
        InvalidateAllRefreshTokens(adminID int64) error

        // LoginSession相关
        CreateLoginSession(session *entities.AdminLoginSession) error

        // 用户管理相关
        GetUserStats() (*dto.UserStats, error)
        GetUserList(req *dto.UserListRequest) (*dto.UserListResponse, error)
        GetUserByID(id int64) (*entities.UserInfo, error)
}

// adminRepository Repository接口的实现
type adminRepository struct{}

// NewAdminRepository 创建新的AdminRepository实例
func NewAdminRepository() AdminRepository <span class="cov0" title="0">{
        return &amp;adminRepository{}
}</span>

// Admin相关方法
func (r *adminRepository) GetByEmail(email string) (*entities.Admin, error) <span class="cov0" title="0">{
        var admin entities.Admin
        err := database.DB.Get(&amp;admin, "SELECT * FROM admins WHERE email = $1", email)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, sql.ErrNoRows
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;admin, nil</span>
}

func (r *adminRepository) GetByID(id int64) (*entities.Admin, error) <span class="cov0" title="0">{
        var admin entities.Admin
        err := database.DB.Get(&amp;admin, "SELECT * FROM admins WHERE id = $1", id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, sql.ErrNoRows
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;admin, nil</span>
}

func (r *adminRepository) Create(admin *entities.Admin) error <span class="cov0" title="0">{
        query := `
                INSERT INTO admins (name, email, password, phone, image_key, role, is_super, status,
                        email_verified, phone_verified, profile_completed)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
                RETURNING id, created_at, updated_at`
        
        return database.DB.QueryRow(query,
                admin.Name,
                admin.Email,
                admin.Password,
                admin.Phone,
                admin.ImageKey,
                admin.Role,
                admin.IsSuper,
                admin.Status,
                admin.EmailVerified,
                admin.PhoneVerified,
                admin.ProfileCompleted,
        ).Scan(&amp;admin.ID, &amp;admin.CreatedAt, &amp;admin.UpdatedAt)
}</span>

func (r *adminRepository) Update(admin *entities.Admin) error <span class="cov0" title="0">{
        query := `
                UPDATE admins 
                SET name = $2, email = $3, phone = $4, image_key = $5, role = $6, 
                        is_super = $7, status = $8, email_verified = $9, phone_verified = $10,
                        profile_completed = $11, updated_at = NOW()
                WHERE id = $1
                RETURNING updated_at`
        
        return database.DB.QueryRow(query,
                admin.ID,
                admin.Name,
                admin.Email,
                admin.Phone,
                admin.ImageKey,
                admin.Role,
                admin.IsSuper,
                admin.Status,
                admin.EmailVerified,
                admin.PhoneVerified,
                admin.ProfileCompleted,
        ).Scan(&amp;admin.UpdatedAt)
}</span>

func (r *adminRepository) UpdateLastLogin(id int64) error <span class="cov0" title="0">{
        _, err := database.DB.Exec("UPDATE admins SET last_login_at = NOW() WHERE id = $1", id)
        return err
}</span>

func (r *adminRepository) UpdatePassword(id int64, password string) error <span class="cov0" title="0">{
        _, err := database.DB.Exec("UPDATE admins SET password = $2, updated_at = NOW() WHERE id = $1", id, password)
        return err
}</span>

func (r *adminRepository) UpdateEmailVerified(id int64, verified bool) error <span class="cov0" title="0">{
        _, err := database.DB.Exec("UPDATE admins SET email_verified = $2, updated_at = NOW() WHERE id = $1", id, verified)
        return err
}</span>

// RefreshToken相关方法
func (r *adminRepository) CreateRefreshToken(token *entities.AdminRefreshToken) error <span class="cov0" title="0">{
        query := `
                INSERT INTO admin_refresh_tokens (admin_id, token, is_valid, expires_at, device_info)
                VALUES ($1, $2, $3, $4, $5)
                RETURNING id, created_at`
        
        return database.DB.QueryRow(query,
                token.AdminID,
                token.Token,
                token.IsValid,
                token.ExpiresAt,
                token.DeviceInfo,
        ).Scan(&amp;token.ID, &amp;token.CreatedAt)
}</span>

func (r *adminRepository) GetValidRefreshToken(token string) (*entities.AdminRefreshToken, error) <span class="cov0" title="0">{
        var refreshToken entities.AdminRefreshToken
        query := `
                SELECT * FROM admin_refresh_tokens 
                WHERE token = $1 AND is_valid = true AND expires_at &gt; NOW()`
        
        err := database.DB.Get(&amp;refreshToken, query, token)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, sql.ErrNoRows
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;refreshToken, nil</span>
}

func (r *adminRepository) InvalidateRefreshToken(token string) error <span class="cov0" title="0">{
        _, err := database.DB.Exec(
                "UPDATE admin_refresh_tokens SET is_valid = false WHERE token = $1",
                token,
        )
        return err
}</span>

func (r *adminRepository) InvalidateAllRefreshTokens(adminID int64) error <span class="cov0" title="0">{
        _, err := database.DB.Exec(
                "UPDATE admin_refresh_tokens SET is_valid = false WHERE admin_id = $1",
                adminID,
        )
        return err
}</span>

// LoginSession相关方法
func (r *adminRepository) CreateLoginSession(session *entities.AdminLoginSession) error <span class="cov0" title="0">{
        query := `
                INSERT INTO admin_login_sessions (
                        admin_id, ip, country, city, region, timezone, organization, location,
                        user_agent, device_type, os, browser, is_trusted, platform, status, reason
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
                RETURNING id, created_at`
        
        return database.DB.QueryRow(query,
                session.AdminID,
                session.IP,
                session.Country,
                session.City,
                session.Region,
                session.Timezone,
                session.Organization,
                session.Location,
                session.UserAgent,
                session.DeviceType,
                session.OS,
                session.Browser,
                session.IsTrusted,
                session.Platform,
                session.Status,
                session.Reason,
        ).Scan(&amp;session.ID, &amp;session.CreatedAt)
}</span>

// 用户管理相关方法
func (r *adminRepository) GetUserStats() (*dto.UserStats, error) <span class="cov0" title="0">{
        var stats dto.UserStats
        
        // 获取总用户数
        err := database.DB.Get(&amp;stats.TotalUsers, "SELECT COUNT(*) FROM users")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        // 获取活跃用户数
        <span class="cov0" title="0">err = database.DB.Get(&amp;stats.ActiveUsers, "SELECT COUNT(*) FROM users WHERE status = 'active'")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        // 获取非活跃用户数
        <span class="cov0" title="0">err = database.DB.Get(&amp;stats.InactiveUsers, "SELECT COUNT(*) FROM users WHERE status = 'inactive'")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        // 获取今日注册用户数
        <span class="cov0" title="0">err = database.DB.Get(&amp;stats.RegisteredToday, 
                "SELECT COUNT(*) FROM users WHERE DATE(created_at) = CURRENT_DATE")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        // 获取本周注册用户数
        <span class="cov0" title="0">err = database.DB.Get(&amp;stats.RegisteredThisWeek, 
                "SELECT COUNT(*) FROM users WHERE created_at &gt;= DATE_TRUNC('week', NOW())")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        // 获取本月注册用户数
        <span class="cov0" title="0">err = database.DB.Get(&amp;stats.RegisteredThisMonth, 
                "SELECT COUNT(*) FROM users WHERE created_at &gt;= DATE_TRUNC('month', NOW())")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">return &amp;stats, nil</span>
}

func (r *adminRepository) GetUserList(req *dto.UserListRequest) (*dto.UserListResponse, error) <span class="cov0" title="0">{
        // 设置默认值
        page := req.Page
        if page == 0 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov0" title="0">pageSize := req.PageSize
        if pageSize == 0 </span><span class="cov0" title="0">{
                pageSize = 20
        }</span>
        <span class="cov0" title="0">offset := (page - 1) * pageSize
        
        // 构建查询条件
        var whereConditions []string
        var args []interface{}
        argIndex := 1
        
        if req.Status != "" &amp;&amp; req.Status != "all" </span><span class="cov0" title="0">{
                whereConditions = append(whereConditions, fmt.Sprintf("status = $%d", argIndex))
                args = append(args, req.Status)
                argIndex++
        }</span>
        
        <span class="cov0" title="0">if req.Email != "" </span><span class="cov0" title="0">{
                whereConditions = append(whereConditions, fmt.Sprintf("email ILIKE $%d", argIndex))
                args = append(args, "%"+req.Email+"%")
                argIndex++
        }</span>
        
        <span class="cov0" title="0">if req.Phone != "" </span><span class="cov0" title="0">{
                whereConditions = append(whereConditions, fmt.Sprintf("phone ILIKE $%d", argIndex))
                args = append(args, "%"+req.Phone+"%")
                argIndex++
        }</span>
        
        // 构建完整查询
        <span class="cov0" title="0">baseQuery := `SELECT id, name, email, phone, image_key, status, 
                                        email_verified, phone_verified, auto_registered, profile_completed, 
                                        last_login_at, created_at FROM users`
        
        whereClause := ""
        if len(whereConditions) &gt; 0 </span><span class="cov0" title="0">{
                whereClause = " WHERE " + whereConditions[0]
                for i := 1; i &lt; len(whereConditions); i++ </span><span class="cov0" title="0">{
                        whereClause += " AND " + whereConditions[i]
                }</span>
        }
        
        // 获取总数
        <span class="cov0" title="0">var total int64
        countQuery := "SELECT COUNT(*) FROM users" + whereClause
        err := database.DB.Get(&amp;total, countQuery, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        // 获取用户列表
        <span class="cov0" title="0">query := baseQuery + whereClause + fmt.Sprintf(" ORDER BY created_at DESC LIMIT $%d OFFSET $%d", argIndex, argIndex+1)
        args = append(args, pageSize, offset)
        
        var users []entities.UserInfo
        err = database.DB.Select(&amp;users, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">return &amp;dto.UserListResponse{
                Total: total,
                Page:  page,
                Size:  pageSize,
                Users: users,
        }, nil</span>
}

func (r *adminRepository) GetUserByID(id int64) (*entities.UserInfo, error) <span class="cov0" title="0">{
        var user entities.UserInfo
        query := `SELECT id, name, email, phone, image_key, status, 
                                email_verified, phone_verified, auto_registered, profile_completed, 
                                last_login_at, created_at 
                          FROM users WHERE id = $1`
        
        err := database.DB.Get(&amp;user, query, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, sql.ErrNoRows
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;user, nil</span>
}</pre>
		
		<pre class="file" id="file3" style="display: none">package admin

import (
        "trusioo_api/internal/middleware"

        "github.com/gin-gonic/gin"
)

func RegisterRoutes(router *gin.RouterGroup, handler *Handler) <span class="cov0" title="0">{
        admin := router.Group("/admin")
        </span><span class="cov0" title="0">{
                // 管理员认证相关路由 - 不需要认证
                auth := admin.Group("/auth")
                </span><span class="cov0" title="0">{
                        auth.POST("/login", handler.Login)
                        auth.POST("/login/verify", handler.LoginVerify)
                        auth.POST("/forgot-password", handler.ForgotPassword) // 管理员忘记密码：发送重置验证码
                        auth.POST("/reset-password", handler.ResetPassword)   // 管理员重置密码：验证码+新密码
                        auth.POST("/refresh", handler.RefreshToken)
                }</span>

                // 需要管理员认证的路由
                <span class="cov0" title="0">adminRoutes := admin.Group("")
                adminRoutes.Use(middleware.AdminAuthMiddleware())
                </span><span class="cov0" title="0">{
                        // 管理员个人信息
                        adminRoutes.GET("/profile", handler.GetProfile)

                        // 用户管理
                        users := adminRoutes.Group("/users")
                        </span><span class="cov0" title="0">{
                                users.GET("/stats", handler.GetUserStats)
                                users.GET("", handler.GetUserList)
                                users.GET("/:id", handler.GetUserDetail)
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package admin

import (
        "context"
        "database/sql"
        "log"
        "strings"
        "time"

        "trusioo_api/config"
        "trusioo_api/internal/auth/admin_auth/dto"
        "trusioo_api/internal/auth/admin_auth/entities"
        "trusioo_api/internal/auth/verification"
        verificationDto "trusioo_api/internal/auth/verification/dto"
        "trusioo_api/internal/common"
        "trusioo_api/pkg/auth"
        "trusioo_api/pkg/ipinfo"

        "golang.org/x/crypto/bcrypt"
)

// Service 管理员业务逻辑服务
type Service struct {
        adminRepo           AdminRepository
        verificationService *verification.Service
        ipinfoClient        ipinfo.Client
}

// NewService 创建新的Service实例
func NewService() *Service <span class="cov0" title="0">{
        ipinfoConfig := ipinfo.LoadConfigFromEnv()
        ipinfoClient := ipinfo.NewClient(ipinfoConfig)

        return &amp;Service{
                adminRepo:           NewAdminRepository(),
                verificationService: verification.NewService(),
                ipinfoClient:        ipinfoClient,
        }
}</span>

// Login 管理员登录第一步 - 验证email+password并发送登录验证码
func (s *Service) Login(req *dto.AdminLoginRequest, clientIP, userAgent string) (*dto.AdminLoginCodeResponse, error) <span class="cov0" title="0">{
        // 1. 验证email+password
        admin, err := s.adminRepo.GetByEmail(req.Email)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        s.recordLoginSession(0, clientIP, userAgent, "failed", "管理员不存在")
                        return nil, common.ErrAdminNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        // 验证密码
        <span class="cov0" title="0">err = bcrypt.CompareHashAndPassword([]byte(admin.Password), []byte(req.Password))
        if err != nil </span><span class="cov0" title="0">{
                s.recordLoginSession(admin.ID, clientIP, userAgent, "failed", "密码错误")
                return nil, common.ErrInvalidAdminCredentials
        }</span>

        // 检查管理员状态 - 必须是激活状态才能登录
        <span class="cov0" title="0">if admin.Status != "active" </span><span class="cov0" title="0">{
                s.recordLoginSession(admin.ID, clientIP, userAgent, "failed", "管理员账户未激活")
                return nil, common.ErrAdminInactive
        }</span>

        // 2. 发送登录验证码
        <span class="cov0" title="0">sendReq := &amp;verificationDto.SendVerificationRequest{
                Target: req.Email,
                Type:   req.VerificationType(),
        }
        _, err = s.verificationService.SendVerificationCode(sendReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;dto.AdminLoginCodeResponse{
                Message:   "管理员登录验证码已发送",
                LoginCode: "已发送到邮箱",
                ExpiresIn: 600, // 10分钟
        }, nil</span>
}

// LoginVerify 管理员登录第二步 - 验证登录验证码并返回token
func (s *Service) LoginVerify(req *dto.AdminLoginVerifyRequest, clientIP, userAgent string) (*dto.AdminLoginResponse, error) <span class="cov0" title="0">{
        // 1. 获取管理员信息
        admin, err := s.adminRepo.GetByEmail(req.Email)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, common.ErrAdminNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        // 2. 验证验证码
        <span class="cov0" title="0">verifyReq := &amp;verificationDto.VerifyCodeRequest{
                Target: req.Email,
                Code:   req.Code,
                Type:   req.VerificationType(),
        }
        verifyResp, err := s.verificationService.VerifyCode(verifyReq)
        if err != nil </span><span class="cov0" title="0">{
                s.recordLoginSession(admin.ID, clientIP, userAgent, "failed", "验证码错误")
                return nil, err
        }</span>
        <span class="cov0" title="0">if !verifyResp.Valid </span><span class="cov0" title="0">{
                s.recordLoginSession(admin.ID, clientIP, userAgent, "failed", "验证码无效")
                return nil, common.ErrInvalidCode
        }</span>

        // 3. 生成访问令牌
        <span class="cov0" title="0">accessToken, err := auth.GenerateAccessToken(admin.ID, admin.Email, admin.Role, "admin")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 4. 生成刷新令牌
        <span class="cov0" title="0">refreshTokenStr, err := auth.GenerateRefreshToken(admin.ID, admin.Email, admin.Role, "admin")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 5. 保存刷新令牌到数据库
        <span class="cov0" title="0">refreshToken := &amp;entities.AdminRefreshToken{
                AdminID:    admin.ID,
                Token:      refreshTokenStr,
                IsValid:    true,
                ExpiresAt:  time.Now().Add(time.Duration(config.AppConfig.JWT.RefreshExpire) * time.Second),
                DeviceInfo: userAgent,
                CreatedAt:  time.Now(),
        }

        err = s.adminRepo.CreateRefreshToken(refreshToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 6. 更新最后登录时间
        <span class="cov0" title="0">err = s.adminRepo.UpdateLastLogin(admin.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 7. 标记邮箱为已验证
        <span class="cov0" title="0">err = s.adminRepo.UpdateEmailVerified(admin.ID, true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 7. 记录登录会话并获取位置信息
        <span class="cov0" title="0">sessionInfo := s.recordLoginSessionWithIPInfo(admin.ID, clientIP, userAgent, "success", "登录成功")

        return &amp;dto.AdminLoginResponse{
                AccessToken:  accessToken,
                RefreshToken: refreshTokenStr,
                ExpiresIn:    int64(config.AppConfig.JWT.AccessExpire),
                TokenType:    "Bearer",
                Admin:        *admin,
                LoginSession: sessionInfo,
        }, nil</span>
}

// RefreshToken 刷新访问令牌
func (s *Service) RefreshToken(req *dto.RefreshTokenRequest) (*dto.AdminLoginResponse, error) <span class="cov0" title="0">{
        // 验证刷新令牌
        claims, err := auth.ValidateRefreshToken(req.RefreshToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, common.ErrTokenInvalid
        }</span>

        // 检查刷新令牌是否在数据库中且有效
        <span class="cov0" title="0">refreshToken, err := s.adminRepo.GetValidRefreshToken(req.RefreshToken)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, common.ErrRefreshTokenInvalid
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        // 验证token所属用户ID
        <span class="cov0" title="0">if refreshToken.AdminID != claims.UserID </span><span class="cov0" title="0">{
                return nil, common.ErrRefreshTokenInvalid
        }</span>

        // 获取管理员信息
        <span class="cov0" title="0">admin, err := s.adminRepo.GetByID(claims.UserID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, common.ErrAdminNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        // 检查管理员状态
        <span class="cov0" title="0">if admin.Status != "active" </span><span class="cov0" title="0">{
                return nil, common.ErrAdminInactive
        }</span>

        // 生成新的访问令牌
        <span class="cov0" title="0">accessToken, err := auth.GenerateAccessToken(admin.ID, admin.Email, admin.Role, "admin")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;dto.AdminLoginResponse{
                AccessToken:  accessToken,
                RefreshToken: req.RefreshToken,
                ExpiresIn:    int64(config.AppConfig.JWT.AccessExpire),
                TokenType:    "Bearer",
                Admin:        *admin,
        }, nil</span>
}

// GetAdminByID 根据ID获取管理员信息
func (s *Service) GetAdminByID(adminID int64) (*entities.Admin, error) <span class="cov0" title="0">{
        admin, err := s.adminRepo.GetByID(adminID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, common.ErrAdminNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return admin, nil</span>
}

// GetUserStats 获取用户统计
func (s *Service) GetUserStats() (*dto.UserStats, error) <span class="cov0" title="0">{
        return s.adminRepo.GetUserStats()
}</span>

// GetUserList 获取用户列表
func (s *Service) GetUserList(req *dto.UserListRequest) (*dto.UserListResponse, error) <span class="cov0" title="0">{
        return s.adminRepo.GetUserList(req)
}</span>

// GetUserByID 根据ID获取用户信息
func (s *Service) GetUserByID(userID int64) (*entities.UserInfo, error) <span class="cov0" title="0">{
        user, err := s.adminRepo.GetUserByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, common.ErrUserNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return user, nil</span>
}

// recordLoginSession 记录登录会话
func (s *Service) recordLoginSession(adminID int64, ip, userAgent, status, reason string) <span class="cov0" title="0">{
        s.recordLoginSessionWithIPInfo(adminID, ip, userAgent, status, reason)
}</span>

func (s *Service) recordLoginSessionWithIPInfo(adminID int64, ip, userAgent, status, reason string) *dto.AdminLoginSessionInfo <span class="cov0" title="0">{
        session := &amp;entities.AdminLoginSession{
                AdminID:   adminID,
                IP:        ip,
                UserAgent: userAgent,
                Status:    status,
                Reason:    reason,
                CreatedAt: time.Now(),
        }

        // 获取IP地理位置信息
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        if ipInfo, err := s.ipinfoClient.GetIPInfo(ctx, ip); err == nil </span><span class="cov0" title="0">{
                session.Country = ipInfo.Country
                session.City = ipInfo.City
                session.Region = ipInfo.Region
                session.Timezone = ipInfo.Timezone
                session.Organization = ipInfo.Org
                session.Location = ipInfo.Loc
        }</span> else<span class="cov0" title="0"> {
                log.Printf("获取IP信息失败 %s: %v", ip, err)
        }</span>

        // 解析User-Agent获取设备信息
        <span class="cov0" title="0">s.parseUserAgent(session, userAgent)

        err := s.adminRepo.CreateLoginSession(session)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("记录管理员登录会话失败: %v", err)
                return nil
        }</span>

        // 返回会话信息给客户端
        <span class="cov0" title="0">if status == "success" </span><span class="cov0" title="0">{
                return &amp;dto.AdminLoginSessionInfo{
                        IP:           session.IP,
                        Country:      session.Country,
                        City:         session.City,
                        Region:       session.Region,
                        Timezone:     session.Timezone,
                        Organization: session.Organization,
                        Location:     session.Location,
                        IsTrusted:    session.IsTrusted,
                }
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *Service) parseUserAgent(session *entities.AdminLoginSession, userAgent string) <span class="cov0" title="0">{
        ua := strings.ToLower(userAgent)

        // 检测设备类型
        if strings.Contains(ua, "mobile") || strings.Contains(ua, "android") || strings.Contains(ua, "iphone") </span><span class="cov0" title="0">{
                session.DeviceType = "mobile"
        }</span> else<span class="cov0" title="0"> if strings.Contains(ua, "tablet") || strings.Contains(ua, "ipad") </span><span class="cov0" title="0">{
                session.DeviceType = "tablet"
        }</span> else<span class="cov0" title="0"> {
                session.DeviceType = "desktop"
        }</span>

        // 检测操作系统
        <span class="cov0" title="0">if strings.Contains(ua, "windows") </span><span class="cov0" title="0">{
                session.OS = "Windows"
        }</span> else<span class="cov0" title="0"> if strings.Contains(ua, "mac") || strings.Contains(ua, "darwin") </span><span class="cov0" title="0">{
                session.OS = "macOS"
        }</span> else<span class="cov0" title="0"> if strings.Contains(ua, "linux") </span><span class="cov0" title="0">{
                session.OS = "Linux"
        }</span> else<span class="cov0" title="0"> if strings.Contains(ua, "android") </span><span class="cov0" title="0">{
                session.OS = "Android"
        }</span> else<span class="cov0" title="0"> if strings.Contains(ua, "iphone") || strings.Contains(ua, "ipad") || strings.Contains(ua, "ios") </span><span class="cov0" title="0">{
                session.OS = "iOS"
        }</span>

        // 检测浏览器
        <span class="cov0" title="0">if strings.Contains(ua, "chrome") &amp;&amp; !strings.Contains(ua, "edge") </span><span class="cov0" title="0">{
                session.Browser = "Chrome"
        }</span> else<span class="cov0" title="0"> if strings.Contains(ua, "firefox") </span><span class="cov0" title="0">{
                session.Browser = "Firefox"
        }</span> else<span class="cov0" title="0"> if strings.Contains(ua, "safari") &amp;&amp; !strings.Contains(ua, "chrome") </span><span class="cov0" title="0">{
                session.Browser = "Safari"
        }</span> else<span class="cov0" title="0"> if strings.Contains(ua, "edge") </span><span class="cov0" title="0">{
                session.Browser = "Edge"
        }</span> else<span class="cov0" title="0"> if strings.Contains(ua, "opera") </span><span class="cov0" title="0">{
                session.Browser = "Opera"
        }</span>

        // 检测平台
        <span class="cov0" title="0">if strings.Contains(ua, "mobile") || strings.Contains(ua, "android") || strings.Contains(ua, "iphone") </span><span class="cov0" title="0">{
                session.Platform = "mobile"
        }</span> else<span class="cov0" title="0"> {
                session.Platform = "web"
        }</span>
}

// ForgotPassword 管理员忘记密码 - 发送重置密码验证码
func (s *Service) ForgotPassword(req *dto.AdminForgotPasswordRequest) (*dto.AdminForgotPasswordResponse, error) <span class="cov0" title="0">{
        // 1. 验证管理员是否存在
        admin, err := s.adminRepo.GetByEmail(req.Email)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        // 为了安全，即使管理员不存在也返回成功，避免暴露管理员是否存在
                        return &amp;dto.AdminForgotPasswordResponse{
                                Message:   "如果该邮箱已注册为管理员，重置密码验证码已发送",
                                ExpiresIn: 600,
                        }, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        // 2. 检查管理员状态
        <span class="cov0" title="0">if admin.Status != "active" </span><span class="cov0" title="0">{
                // 为了安全，不暴露账户状态信息
                return &amp;dto.AdminForgotPasswordResponse{
                        Message:   "如果该邮箱已注册为管理员，重置密码验证码已发送",
                        ExpiresIn: 600,
                }, nil
        }</span>

        // 3. 发送重置密码验证码
        <span class="cov0" title="0">sendReq := &amp;verificationDto.SendVerificationRequest{
                Target: req.Email,
                Type:   "admin_forgot_password",
        }
        _, err = s.verificationService.SendVerificationCode(sendReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;dto.AdminForgotPasswordResponse{
                Message:   "管理员重置密码验证码已发送到您的邮箱",
                ExpiresIn: 600, // 10分钟
        }, nil</span>
}

// ResetPassword 管理员重置密码 - 验证验证码并重置密码
func (s *Service) ResetPassword(req *dto.AdminResetPasswordRequest) (*dto.AdminResetPasswordResponse, error) <span class="cov0" title="0">{
        // 1. 验证管理员是否存在
        admin, err := s.adminRepo.GetByEmail(req.Email)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, common.ErrAdminNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        // 2. 验证重置密码验证码
        <span class="cov0" title="0">verifyReq := &amp;verificationDto.VerifyCodeRequest{
                Target: req.Email,
                Code:   req.Code,
                Type:   "admin_forgot_password",
        }
        verifyResp, err := s.verificationService.VerifyCode(verifyReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if !verifyResp.Valid </span><span class="cov0" title="0">{
                return nil, common.ErrInvalidCode
        }</span>

        // 3. 加密新密码
        <span class="cov0" title="0">hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 4. 更新密码
        <span class="cov0" title="0">err = s.adminRepo.UpdatePassword(admin.ID, string(hashedPassword))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 5. 可选：使所有refresh token失效，强制重新登录
        <span class="cov0" title="0">err = s.adminRepo.InvalidateAllRefreshTokens(admin.ID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to invalidate refresh tokens for admin %d: %v", admin.ID, err)
                // 不返回错误，因为密码已经重置成功
        }</span>

        <span class="cov0" title="0">return &amp;dto.AdminResetPasswordResponse{
                Message: "管理员密码重置成功，请使用新密码登录",
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package dto

import "trusioo_api/internal/auth/user_auth/entities"

// RegisterRequest 注册请求 - 简化为email+password
type RegisterRequest struct {
        Email    string `json:"email" binding:"required,email"`
        Password string `json:"password" binding:"required,min=6"`
}

// LoginRequest 登录请求 - 第一步：验证email+password并发送验证码
type LoginRequest struct {
        Email    string `json:"email" binding:"required,email"`
        Password string `json:"password" binding:"required"`
}

// VerificationType 返回用户登录的验证类型
func (r *LoginRequest) VerificationType() string <span class="cov8" title="1">{
        return "user_login"
}</span>

// LoginVerifyRequest 登录验证请求 - 第二步：验证登录验证码
// 注意：此请求在Service层会自动添加 type: "user_login" 字段调用verification服务
type LoginVerifyRequest struct {
        Email string `json:"email" binding:"required,email"`
        Code  string `json:"code" binding:"required,len=6"`
}

// VerificationType 返回此DTO对应的验证类型
func (r *LoginVerifyRequest) VerificationType() string <span class="cov0" title="0">{
        return "user_login"
}</span>

// LoginCodeResponse 登录验证码响应
type LoginCodeResponse struct {
        Message   string `json:"message"`
        LoginCode string `json:"login_code"`
        ExpiresIn int    `json:"expires_in"` // 秒
}

// LoginResponse 登录响应
type LoginResponse struct {
        AccessToken  string            `json:"access_token"`
        RefreshToken string            `json:"refresh_token"`
        ExpiresIn    int64             `json:"expires_in"`
        TokenType    string            `json:"token_type"`
        User         *entities.User    `json:"user"`
        LoginSession *LoginSessionInfo `json:"login_session,omitempty"`
}

// LoginSessionInfo 登录会话信息
type LoginSessionInfo struct {
        IP           string `json:"ip"`
        Country      string `json:"country"`
        City         string `json:"city"`
        Region       string `json:"region"`
        Timezone     string `json:"timezone"`
        Organization string `json:"organization"`
        Location     string `json:"location"`
        IsTrusted    bool   `json:"is_trusted"`
}

// RegisterResponse 注册响应
type RegisterResponse struct {
        User *entities.User `json:"user"`
}

// RefreshTokenRequest 刷新令牌请求
type RefreshTokenRequest struct {
        RefreshToken string `json:"refresh_token" binding:"required"`
}

// ForgotPasswordRequest 忘记密码请求
type ForgotPasswordRequest struct {
        Email string `json:"email" binding:"required,email"`
}

// ForgotPasswordResponse 忘记密码响应
type ForgotPasswordResponse struct {
        Message   string `json:"message"`
        ExpiresIn int    `json:"expires_in"` // 秒
}

// ResetPasswordRequest 重置密码请求
type ResetPasswordRequest struct {
        Email    string `json:"email" binding:"required,email"`
        Code     string `json:"code" binding:"required,len=6"`
        Password string `json:"password" binding:"required,min=6"`
}

// ResetPasswordResponse 重置密码响应
type ResetPasswordResponse struct {
        Message string `json:"message"`
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package user_auth

import (
        "trusioo_api/internal/auth/user_auth/dto"
        "trusioo_api/internal/common"

        "github.com/gin-gonic/gin"
)

type Handler struct {
        service *Service
}

func NewHandler(service *Service) *Handler <span class="cov0" title="0">{
        return &amp;Handler{service: service}
}</span>

// Register 用户注册
// @Summary 用户注册
// @Description 创建新用户账户
// @Tags 认证
// @Accept json
// @Produce json
// @Param request body RegisterRequest true "注册请求参数"
// @Success 200 {object} common.Response{data=RegisterResponse} "注册成功"
// @Failure 400 {object} common.Response "参数错误或邮箱已存在"
// @Failure 500 {object} common.Response "服务器错误"
// @Router /api/v1/auth/register [post]
func (h *Handler) Register(c *gin.Context) <span class="cov0" title="0">{
        var req dto.RegisterRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                common.ValidationError(c, err.Error())
                return
        }</span>

        <span class="cov0" title="0">resp, err := h.service.Register(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case common.ErrEmailExists:<span class="cov0" title="0">
                        common.ValidationError(c, "Email already registered")</span>
                case common.ErrPhoneExists:<span class="cov0" title="0">
                        common.ValidationError(c, "Phone number already registered")</span>
                default:<span class="cov0" title="0">
                        common.ServerError(c, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">common.Success(c, resp)</span>
}

// Login 用户登录第一步 - 验证email+password并发送验证码
// @Summary 用户登录第一步
// @Description 验证用户邮箱和密码，成功后发送登录验证码
// @Tags 认证
// @Accept json
// @Produce json
// @Param request body LoginRequest true "登录请求参数"
// @Success 200 {object} common.Response{data=LoginCodeResponse} "验证码发送成功"
// @Failure 400 {object} common.Response "参数错误或验证失败"
// @Failure 500 {object} common.Response "服务器错误"
// @Router /api/v1/auth/login [post]
func (h *Handler) Login(c *gin.Context) <span class="cov0" title="0">{
        var req dto.LoginRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                common.ValidationError(c, err.Error())
                return
        }</span>

        <span class="cov0" title="0">clientIP := c.ClientIP()
        userAgent := c.GetHeader("User-Agent")

        resp, err := h.service.Login(&amp;req, clientIP, userAgent)
        if err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case common.ErrUserNotFound:<span class="cov0" title="0">
                        common.ValidationError(c, "User does not exist")</span>
                case common.ErrInvalidCredentials:<span class="cov0" title="0">
                        common.ValidationError(c, "Email or password is incorrect")</span>
                case common.ErrUserInactive:<span class="cov0" title="0">
                        common.ValidationError(c, "Account not activated, please verify your email first")</span>
                default:<span class="cov0" title="0">
                        common.ServerError(c, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">common.Success(c, resp)</span>
}

// LoginVerify 用户登录第二步 - 验证登录验证码
// @Summary 用户登录第二步
// @Description 验证登录验证码并返回访问令牌
// @Tags 认证
// @Accept json
// @Produce json
// @Param request body LoginVerifyRequest true "登录验证请求参数"
// @Success 200 {object} common.Response{data=LoginResponse} "登录成功"
// @Failure 400 {object} common.Response "参数错误或验证失败"
// @Failure 500 {object} common.Response "服务器错误"
// @Router /api/v1/auth/login/verify [post]
func (h *Handler) LoginVerify(c *gin.Context) <span class="cov0" title="0">{
        var req dto.LoginVerifyRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                common.ValidationError(c, err.Error())
                return
        }</span>

        <span class="cov0" title="0">clientIP := c.ClientIP()
        userAgent := c.GetHeader("User-Agent")

        resp, err := h.service.LoginVerify(&amp;req, clientIP, userAgent)
        if err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case common.ErrInvalidCredentials:<span class="cov0" title="0">
                        common.ValidationError(c, "Invalid credentials")</span>
                case common.ErrInvalidCode:<span class="cov0" title="0">
                        common.ValidationError(c, "Invalid or expired verification code")</span>
                default:<span class="cov0" title="0">
                        common.ServerError(c, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">common.Success(c, resp)</span>
}

// RefreshToken 刷新访问令牌
// @Summary 刷新访问令牌
// @Description 使用刷新令牌获取新的访问令牌
// @Tags 认证
// @Accept json
// @Produce json
// @Param request body RefreshTokenRequest true "刷新令牌请求参数"
// @Success 200 {object} common.Response{data=LoginResponse} "刷新成功"
// @Failure 400 {object} common.Response "参数错误或令牌无效"
// @Failure 500 {object} common.Response "服务器错误"
// @Router /api/v1/auth/refresh [post]
func (h *Handler) RefreshToken(c *gin.Context) <span class="cov0" title="0">{
        var req dto.RefreshTokenRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                common.ValidationError(c, err.Error())
                return
        }</span>

        <span class="cov0" title="0">resp, err := h.service.RefreshToken(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case common.ErrTokenInvalid, common.ErrRefreshTokenInvalid:<span class="cov0" title="0">
                        common.Unauthorized(c, "Invalid refresh token")</span>
                case common.ErrUserNotFound:<span class="cov0" title="0">
                        common.ValidationError(c, "User not found")</span>
                case common.ErrUserInactive:<span class="cov0" title="0">
                        common.ValidationError(c, "Account not activated")</span>
                default:<span class="cov0" title="0">
                        common.ServerError(c, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">common.Success(c, resp)</span>
}

// GetProfile 获取用户资料
// @Summary 获取用户资料
// @Description 获取当前登录用户的个人资料
// @Tags 认证
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Success 200 {object} common.Response{data=User} "获取成功"
// @Failure 401 {object} common.Response "未授权"
// @Failure 500 {object} common.Response "服务器错误"
// @Router /api/v1/auth/profile [get]
func (h *Handler) GetProfile(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                common.Unauthorized(c, "User not authenticated")
                return
        }</span>

        <span class="cov0" title="0">user, err := h.service.GetUserByID(userID.(int64))
        if err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case common.ErrUserNotFound:<span class="cov0" title="0">
                        common.NotFound(c, "User not found")</span>
                default:<span class="cov0" title="0">
                        common.ServerError(c, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">common.Success(c, user)</span>
}

// ForgotPassword 忘记密码第一步 - 发送重置密码验证码
// @Summary 忘记密码第一步
// @Description 发送重置密码验证码到用户邮箱
// @Tags 认证
// @Accept json
// @Produce json
// @Param request body ForgotPasswordRequest true "忘记密码请求参数"
// @Success 200 {object} common.Response{data=ForgotPasswordResponse} "验证码发送成功"
// @Failure 400 {object} common.Response "参数错误"
// @Failure 500 {object} common.Response "服务器错误"
// @Router /api/v1/auth/forgot-password [post]
func (h *Handler) ForgotPassword(c *gin.Context) <span class="cov0" title="0">{
        var req dto.ForgotPasswordRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                common.ValidationError(c, err.Error())
                return
        }</span>

        <span class="cov0" title="0">resp, err := h.service.ForgotPassword(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                common.ServerError(c, err)
                return
        }</span>

        <span class="cov0" title="0">common.Success(c, resp)</span>
}

// ResetPassword 忘记密码第二步 - 验证验证码并重置密码
// @Summary 忘记密码第二步
// @Description 验证重置密码验证码并设置新密码
// @Tags 认证
// @Accept json
// @Produce json
// @Param request body ResetPasswordRequest true "重置密码请求参数"
// @Success 200 {object} common.Response{data=ResetPasswordResponse} "密码重置成功"
// @Failure 400 {object} common.Response "参数错误或验证失败"
// @Failure 500 {object} common.Response "服务器错误"
// @Router /api/v1/auth/reset-password [post]
func (h *Handler) ResetPassword(c *gin.Context) <span class="cov0" title="0">{
        var req dto.ResetPasswordRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                common.ValidationError(c, err.Error())
                return
        }</span>

        <span class="cov0" title="0">resp, err := h.service.ResetPassword(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case common.ErrUserNotFound:<span class="cov0" title="0">
                        common.ValidationError(c, "User not found")</span>
                case common.ErrInvalidCode:<span class="cov0" title="0">
                        common.ValidationError(c, "Invalid or expired verification code")</span>
                default:<span class="cov0" title="0">
                        common.ServerError(c, err)</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">common.Success(c, resp)</span>
}

</pre>
		
		<pre class="file" id="file7" style="display: none">package user_auth

import (
        "database/sql"
        "log"

        "trusioo_api/internal/auth/user_auth/entities"
        "trusioo_api/pkg/database"
)

// UserRepository 用户数据访问接口
type UserRepository interface {
        // User相关
        GetByEmail(email string) (*entities.User, error)
        GetByID(id int64) (*entities.User, error)
        GetByPhone(phone string) (*entities.User, error)
        Create(user *entities.User) error
        Update(user *entities.User) error
        UpdateLastLogin(id int64) error
        UpdatePassword(id int64, password string) error
        UpdateEmailVerified(id int64, verified bool) error

        // RefreshToken相关
        CreateRefreshToken(token *entities.RefreshToken) error
        GetValidRefreshToken(token string) (*entities.RefreshToken, error)
        InvalidateRefreshToken(token string) error
        InvalidateAllRefreshTokens(userID int64) error

        // LoginSession相关
        CreateLoginSession(session *entities.LoginSession) error
}

// userRepository Repository接口的实现
type userRepository struct{}

// Repository 类型别名，用于向后兼容
type Repository = UserRepository

// NewRepository 创建新的Repository实例
func NewRepository() Repository <span class="cov0" title="0">{
        return &amp;userRepository{}
}</span>

// NewUserRepository 创建新的UserRepository实例
func NewUserRepository() UserRepository <span class="cov0" title="0">{
        return &amp;userRepository{}
}</span>

// User相关方法
func (r *userRepository) GetByEmail(email string) (*entities.User, error) <span class="cov0" title="0">{
        var user entities.User
        err := database.DB.Get(&amp;user, "SELECT * FROM users WHERE email = $1", email)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, sql.ErrNoRows
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (r *userRepository) GetByID(id int64) (*entities.User, error) <span class="cov0" title="0">{
        var user entities.User
        err := database.DB.Get(&amp;user, "SELECT * FROM users WHERE id = $1", id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, sql.ErrNoRows
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (r *userRepository) GetByPhone(phone string) (*entities.User, error) <span class="cov0" title="0">{
        var user entities.User
        err := database.DB.Get(&amp;user, "SELECT * FROM users WHERE phone = $1", phone)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, sql.ErrNoRows
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (r *userRepository) Create(user *entities.User) error <span class="cov0" title="0">{
        // 调试信息
        log.Printf("Creating user with status: %s", user.Status)
        
        query := `
                INSERT INTO users (name, email, password, phone, image_key, role, status,
                        email_verified, phone_verified, auto_registered, profile_completed, password_set)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
                RETURNING id, created_at, updated_at, status`
        
        var returnedStatus string
        err := database.DB.QueryRow(query,
                user.Name,
                user.Email,
                user.Password,
                user.Phone,
                user.ImageKey,
                user.Role,
                user.Status,
                user.EmailVerified,
                user.PhoneVerified,
                user.AutoRegistered,
                user.ProfileCompleted,
                user.PasswordSet,
        ).Scan(&amp;user.ID, &amp;user.CreatedAt, &amp;user.UpdatedAt, &amp;returnedStatus)
        
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        // 调试信息
        <span class="cov0" title="0">log.Printf("User created with ID: %d, status: %s", user.ID, returnedStatus)
        user.Status = returnedStatus
        
        return nil</span>
}

func (r *userRepository) Update(user *entities.User) error <span class="cov0" title="0">{
        query := `
                UPDATE users 
                SET name = $2, email = $3, phone = $4, image_key = $5, role = $6,
                        status = $7, email_verified = $8, phone_verified = $9, auto_registered = $10,
                        profile_completed = $11, password_set = $12, updated_at = NOW()
                WHERE id = $1
                RETURNING updated_at`
        
        return database.DB.QueryRow(query,
                user.ID,
                user.Name,
                user.Email,
                user.Phone,
                user.ImageKey,
                user.Role,
                user.Status,
                user.EmailVerified,
                user.PhoneVerified,
                user.AutoRegistered,
                user.ProfileCompleted,
                user.PasswordSet,
        ).Scan(&amp;user.UpdatedAt)
}</span>

func (r *userRepository) UpdateLastLogin(id int64) error <span class="cov0" title="0">{
        _, err := database.DB.Exec("UPDATE users SET last_login_at = NOW() WHERE id = $1", id)
        return err
}</span>

func (r *userRepository) UpdatePassword(id int64, password string) error <span class="cov0" title="0">{
        _, err := database.DB.Exec("UPDATE users SET password = $2, updated_at = NOW() WHERE id = $1", id, password)
        return err
}</span>

func (r *userRepository) UpdateEmailVerified(id int64, verified bool) error <span class="cov0" title="0">{
        _, err := database.DB.Exec("UPDATE users SET email_verified = $2, updated_at = NOW() WHERE id = $1", id, verified)
        return err
}</span>

// RefreshToken相关方法
func (r *userRepository) CreateRefreshToken(token *entities.RefreshToken) error <span class="cov0" title="0">{
        query := `
                INSERT INTO user_refresh_tokens (user_id, token, is_valid, expires_at, device_info)
                VALUES ($1, $2, $3, $4, $5)
                RETURNING id, created_at`
        
        return database.DB.QueryRow(query,
                token.UserID,
                token.Token,
                token.IsValid,
                token.ExpiresAt,
                token.DeviceInfo,
        ).Scan(&amp;token.ID, &amp;token.CreatedAt)
}</span>

func (r *userRepository) GetValidRefreshToken(token string) (*entities.RefreshToken, error) <span class="cov0" title="0">{
        var refreshToken entities.RefreshToken
        query := `
                SELECT * FROM user_refresh_tokens 
                WHERE token = $1 AND is_valid = true AND expires_at &gt; NOW()`
        
        err := database.DB.Get(&amp;refreshToken, query, token)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, sql.ErrNoRows
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;refreshToken, nil</span>
}

func (r *userRepository) InvalidateRefreshToken(token string) error <span class="cov0" title="0">{
        _, err := database.DB.Exec(
                "UPDATE user_refresh_tokens SET is_valid = false WHERE token = $1",
                token,
        )
        return err
}</span>

func (r *userRepository) InvalidateAllRefreshTokens(userID int64) error <span class="cov0" title="0">{
        _, err := database.DB.Exec(
                "UPDATE user_refresh_tokens SET is_valid = false WHERE user_id = $1",
                userID,
        )
        return err
}</span>

// LoginSession相关方法
func (r *userRepository) CreateLoginSession(session *entities.LoginSession) error <span class="cov0" title="0">{
        query := `
                INSERT INTO user_login_sessions (
                        user_id, ip, country, city, region, timezone, organization, location,
                        user_agent, device_type, os, browser, is_trusted, login_method, platform, status, reason
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17)
                RETURNING id, created_at`
        
        return database.DB.QueryRow(query,
                session.UserID,
                session.IP,
                session.Country,
                session.City,
                session.Region,
                session.Timezone,
                session.Organization,
                session.Location,
                session.UserAgent,
                session.DeviceType,
                session.OS,
                session.Browser,
                session.IsTrusted,
                session.LoginMethod,
                session.Platform,
                session.Status,
                session.Reason,
        ).Scan(&amp;session.ID, &amp;session.CreatedAt)
}</pre>
		
		<pre class="file" id="file8" style="display: none">package user_auth

import (
        "trusioo_api/internal/middleware"

        "github.com/gin-gonic/gin"
)

func RegisterRoutes(router *gin.RouterGroup, handler *Handler) <span class="cov0" title="0">{
        // 公开路由 - 不需要认证
        router.POST("/register", handler.Register)        // 注册用户（未激活）
        router.POST("/login", handler.Login)              // 登录第一步：验证email+password
        router.POST("/login/verify", handler.LoginVerify) // 登录第二步：验证登录验证码

        router.POST("/forgot-password", handler.ForgotPassword) // 忘记密码：发送重置验证码
        router.POST("/reset-password", handler.ResetPassword)   // 重置密码：验证码+新密码

        router.POST("/refresh", handler.RefreshToken)

        // 需要认证的路由
        authRoutes := router.Group("")
        authRoutes.Use(middleware.AuthMiddleware())
        </span><span class="cov0" title="0">{
                authRoutes.GET("/profile", handler.GetProfile)
        }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package user_auth

import (
        "context"
        "database/sql"
        "log"
        "strings"
        "time"

        "trusioo_api/config"
        "trusioo_api/internal/auth/user_auth/dto"
        "trusioo_api/internal/auth/user_auth/entities"
        "trusioo_api/internal/auth/verification"
        verificationDto "trusioo_api/internal/auth/verification/dto"
        "trusioo_api/internal/common"
        "trusioo_api/pkg/auth"
        "trusioo_api/pkg/ipinfo"

        "golang.org/x/crypto/bcrypt"
)

// VerificationService 验证服务接口
type VerificationService interface {
        SendVerificationCode(req *verificationDto.SendVerificationRequest) (*verificationDto.SendVerificationResponse, error)
        VerifyCode(req *verificationDto.VerifyCodeRequest) (*verificationDto.VerifyCodeResponse, error)
}

type Service struct {
        repo                Repository
        verificationService VerificationService
        ipinfoClient        ipinfo.Client
}

func NewService(repo Repository) *Service <span class="cov0" title="0">{
        ipinfoConfig := ipinfo.LoadConfigFromEnv()
        ipinfoClient := ipinfo.NewClient(ipinfoConfig)

        return &amp;Service{
                repo:                repo,
                verificationService: verification.NewService(),
                ipinfoClient:        ipinfoClient,
        }
}</span>

func (s *Service) Register(req *dto.RegisterRequest) (*dto.RegisterResponse, error) <span class="cov8" title="1">{
        // 检查邮箱是否已存在
        _, err := s.repo.GetByEmail(req.Email)
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                return nil, common.ErrEmailExists
        }</span>

        // 加密密码
        <span class="cov8" title="1">hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 创建用户 - 状态为激活但邮箱未验证
        <span class="cov8" title="1">user := &amp;entities.User{
                Name:             "", // 注册时不需要姓名
                Email:            req.Email,
                Password:         string(hashedPassword),
                Phone:            nil, // 注册时不需要手机号
                ImageKey:         "",
                Role:             "user",
                Status:           "active", // 允许登录
                EmailVerified:    false,    // 需要通过登录验证码验证邮箱
                PhoneVerified:    false,
                AutoRegistered:   false,
                ProfileCompleted: false,
                PasswordSet:      true, // 密码已设置
                CreatedAt:        time.Now(),
                UpdatedAt:        time.Now(),
        }

        err = s.repo.Create(user)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;dto.RegisterResponse{
                User: user,
        }, nil</span>
}

// Login 第一步登录 - 验证email+password并发送登录验证码
func (s *Service) Login(req *dto.LoginRequest, clientIP, userAgent string) (*dto.LoginCodeResponse, error) <span class="cov8" title="1">{
        // 1. 验证email+password
        user, err := s.repo.GetByEmail(req.Email)
        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        s.recordLoginSession(0, clientIP, userAgent, "email", "failed", "用户不存在")
                        return nil, common.ErrUserNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        // 验证密码
        <span class="cov8" title="1">err = bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(req.Password))
        if err != nil </span><span class="cov8" title="1">{
                s.recordLoginSession(user.ID, clientIP, userAgent, "email", "failed", "密码错误")
                return nil, common.ErrInvalidCredentials
        }</span>

        // 检查用户状态 - 必须是激活状态才能登录
        <span class="cov8" title="1">if user.Status != "active" </span><span class="cov0" title="0">{
                s.recordLoginSession(user.ID, clientIP, userAgent, "email", "failed", "账户未激活")
                return nil, common.ErrUserInactive
        }</span>

        // 2. 发送登录验证码
        <span class="cov8" title="1">sendReq := &amp;verificationDto.SendVerificationRequest{
                Target: req.Email,
                Type:   req.VerificationType(),
        }
        _, err = s.verificationService.SendVerificationCode(sendReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;dto.LoginCodeResponse{
                Message:   "用户登录验证码已发送",
                LoginCode: "已发送到邮箱",
                ExpiresIn: 600, // 10分钟
        }, nil</span>
}

// LoginVerify 第二步登录 - 验证登录验证码并返回token
func (s *Service) LoginVerify(req *dto.LoginVerifyRequest, clientIP, userAgent string) (*dto.LoginResponse, error) <span class="cov0" title="0">{
        // 1. 获取用户信息
        user, err := s.repo.GetByEmail(req.Email)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, common.ErrUserNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        // 2. 验证验证码
        <span class="cov0" title="0">verifyReq := &amp;verificationDto.VerifyCodeRequest{
                Target: req.Email,
                Code:   req.Code,
                Type:   req.VerificationType(),
        }
        verifyResp, err := s.verificationService.VerifyCode(verifyReq)
        if err != nil </span><span class="cov0" title="0">{
                s.recordLoginSession(user.ID, clientIP, userAgent, "email", "failed", "验证码错误")
                return nil, err
        }</span>
        <span class="cov0" title="0">if !verifyResp.Valid </span><span class="cov0" title="0">{
                s.recordLoginSession(user.ID, clientIP, userAgent, "email", "failed", "验证码无效")
                return nil, common.ErrInvalidCode
        }</span>

        // 3. 生成访问令牌
        <span class="cov0" title="0">accessToken, err := auth.GenerateAccessToken(user.ID, user.Email, user.Role, "user")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 4. 生成刷新令牌
        <span class="cov0" title="0">refreshTokenStr, err := auth.GenerateRefreshToken(user.ID, user.Email, user.Role, "user")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 5. 保存刷新令牌
        <span class="cov0" title="0">refreshToken := &amp;entities.RefreshToken{
                UserID:     user.ID,
                Token:      refreshTokenStr,
                IsValid:    true,
                ExpiresAt:  time.Now().Add(time.Duration(config.AppConfig.JWT.RefreshExpire) * time.Second),
                DeviceInfo: userAgent,
                CreatedAt:  time.Now(),
        }

        err = s.repo.CreateRefreshToken(refreshToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 6. 更新最后登录时间
        <span class="cov0" title="0">err = s.repo.UpdateLastLogin(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 7. 标记邮箱为已验证（通过登录验证码验证了邮箱所有权）
        <span class="cov0" title="0">err = s.repo.UpdateEmailVerified(user.ID, true)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to update email_verified for user %d: %v", user.ID, err)
                // 不返回错误，因为登录流程已经成功
        }</span>

        // 8. 记录登录会话并获取位置信息
        <span class="cov0" title="0">sessionInfo := s.recordLoginSessionWithIPInfo(user.ID, clientIP, userAgent, "email", "success", "登录成功")

        return &amp;dto.LoginResponse{
                AccessToken:  accessToken,
                RefreshToken: refreshTokenStr,
                TokenType:    "Bearer",
                ExpiresIn:    int64(config.AppConfig.JWT.AccessExpire),
                User: &amp;entities.User{
                        ID:     user.ID,
                        Name:   user.Name,
                        Email:  user.Email,
                        Phone:  user.Phone,
                        Role:   user.Role,
                        Status: user.Status,
                },
                LoginSession: sessionInfo,
        }, nil</span>
}

func (s *Service) RefreshToken(req *dto.RefreshTokenRequest) (*dto.LoginResponse, error) <span class="cov0" title="0">{
        // 验证刷新令牌
        refreshToken, err := s.repo.GetValidRefreshToken(req.RefreshToken)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, common.ErrRefreshTokenInvalid
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        // 获取用户信息
        <span class="cov0" title="0">user, err := s.repo.GetByID(refreshToken.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 生成新的访问令牌
        <span class="cov0" title="0">accessToken, err := auth.GenerateAccessToken(user.ID, user.Email, user.Role, "user")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;dto.LoginResponse{
                AccessToken:  accessToken,
                RefreshToken: req.RefreshToken,
                TokenType:    "Bearer",
                ExpiresIn:    int64(config.AppConfig.JWT.AccessExpire),
                User: &amp;entities.User{
                        ID:     user.ID,
                        Name:   user.Name,
                        Email:  user.Email,
                        Phone:  user.Phone,
                        Role:   user.Role,
                        Status: user.Status,
                },
        }, nil</span>
}

func (s *Service) GetUserByID(userID int64) (*entities.User, error) <span class="cov0" title="0">{
        return s.repo.GetByID(userID)
}</span>

// ForgotPassword 忘记密码 - 发送重置密码验证码
func (s *Service) ForgotPassword(req *dto.ForgotPasswordRequest) (*dto.ForgotPasswordResponse, error) <span class="cov0" title="0">{
        // 1. 验证用户是否存在
        user, err := s.repo.GetByEmail(req.Email)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        // 为了安全，即使用户不存在也返回成功，避免暴露用户是否存在
                        return &amp;dto.ForgotPasswordResponse{
                                Message:   "如果该邮箱已注册，重置密码验证码已发送",
                                ExpiresIn: 600,
                        }, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        // 2. 检查用户状态
        <span class="cov0" title="0">if user.Status != "active" </span><span class="cov0" title="0">{
                // 为了安全，不暴露账户状态信息
                return &amp;dto.ForgotPasswordResponse{
                        Message:   "如果该邮箱已注册，重置密码验证码已发送",
                        ExpiresIn: 600,
                }, nil
        }</span>

        // 3. 发送重置密码验证码
        <span class="cov0" title="0">sendReq := &amp;verificationDto.SendVerificationRequest{
                Target: req.Email,
                Type:   "forgot_password",
        }
        _, err = s.verificationService.SendVerificationCode(sendReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;dto.ForgotPasswordResponse{
                Message:   "重置密码验证码已发送到您的邮箱",
                ExpiresIn: 600, // 10分钟
        }, nil</span>
}

// ResetPassword 重置密码 - 验证验证码并重置密码
func (s *Service) ResetPassword(req *dto.ResetPasswordRequest) (*dto.ResetPasswordResponse, error) <span class="cov0" title="0">{
        // 1. 验证用户是否存在
        user, err := s.repo.GetByEmail(req.Email)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, common.ErrUserNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        // 2. 验证重置密码验证码
        <span class="cov0" title="0">verifyReq := &amp;verificationDto.VerifyCodeRequest{
                Target: req.Email,
                Code:   req.Code,
                Type:   "forgot_password",
        }
        verifyResp, err := s.verificationService.VerifyCode(verifyReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if !verifyResp.Valid </span><span class="cov0" title="0">{
                return nil, common.ErrInvalidCode
        }</span>

        // 3. 加密新密码
        <span class="cov0" title="0">hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 4. 更新密码
        <span class="cov0" title="0">err = s.repo.UpdatePassword(user.ID, string(hashedPassword))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 5. 可选：使所有refresh token失效，强制重新登录
        <span class="cov0" title="0">err = s.repo.InvalidateAllRefreshTokens(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to invalidate refresh tokens for user %d: %v", user.ID, err)
                // 不返回错误，因为密码已经重置成功
        }</span>

        <span class="cov0" title="0">return &amp;dto.ResetPasswordResponse{
                Message: "密码重置成功，请使用新密码登录",
        }, nil</span>
}

func (s *Service) recordLoginSession(userID int64, ip, userAgent, method, status, reason string) <span class="cov8" title="1">{
        s.recordLoginSessionWithIPInfo(userID, ip, userAgent, method, status, reason)
}</span>

func (s *Service) recordLoginSessionWithIPInfo(userID int64, ip, userAgent, method, status, reason string) *dto.LoginSessionInfo <span class="cov8" title="1">{
        session := &amp;entities.LoginSession{
                UserID:      userID,
                IP:          ip,
                UserAgent:   userAgent,
                LoginMethod: method,
                Status:      status,
                Reason:      reason,
                CreatedAt:   time.Now(),
        }

        // 获取IP地理位置信息
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        if ipInfo, err := s.ipinfoClient.GetIPInfo(ctx, ip); err == nil </span><span class="cov8" title="1">{
                session.Country = ipInfo.Country
                session.City = ipInfo.City
                session.Region = ipInfo.Region
                session.Timezone = ipInfo.Timezone
                session.Organization = ipInfo.Org
                session.Location = ipInfo.Loc
        }</span> else<span class="cov0" title="0"> {
                log.Printf("获取IP信息失败 %s: %v", ip, err)
        }</span>

        // 解析User-Agent获取设备信息
        <span class="cov8" title="1">s.parseUserAgent(session, userAgent)

        err := s.repo.CreateLoginSession(session)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("记录登录会话失败: %v", err)
                return nil
        }</span>

        // 返回会话信息给客户端
        <span class="cov8" title="1">if status == "success" </span><span class="cov0" title="0">{
                return &amp;dto.LoginSessionInfo{
                        IP:           session.IP,
                        Country:      session.Country,
                        City:         session.City,
                        Region:       session.Region,
                        Timezone:     session.Timezone,
                        Organization: session.Organization,
                        Location:     session.Location,
                        IsTrusted:    session.IsTrusted,
                }
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *Service) parseUserAgent(session *entities.LoginSession, userAgent string) <span class="cov8" title="1">{
        ua := strings.ToLower(userAgent)

        // 检测设备类型
        if strings.Contains(ua, "mobile") || strings.Contains(ua, "android") || strings.Contains(ua, "iphone") </span><span class="cov0" title="0">{
                session.DeviceType = "mobile"
        }</span> else<span class="cov8" title="1"> if strings.Contains(ua, "tablet") || strings.Contains(ua, "ipad") </span><span class="cov0" title="0">{
                session.DeviceType = "tablet"
        }</span> else<span class="cov8" title="1"> {
                session.DeviceType = "desktop"
        }</span>

        // 检测操作系统
        <span class="cov8" title="1">if strings.Contains(ua, "windows") </span><span class="cov0" title="0">{
                session.OS = "Windows"
        }</span> else<span class="cov8" title="1"> if strings.Contains(ua, "mac") || strings.Contains(ua, "darwin") </span><span class="cov0" title="0">{
                session.OS = "macOS"
        }</span> else<span class="cov8" title="1"> if strings.Contains(ua, "linux") </span><span class="cov0" title="0">{
                session.OS = "Linux"
        }</span> else<span class="cov8" title="1"> if strings.Contains(ua, "android") </span><span class="cov0" title="0">{
                session.OS = "Android"
        }</span> else<span class="cov8" title="1"> if strings.Contains(ua, "iphone") || strings.Contains(ua, "ipad") || strings.Contains(ua, "ios") </span><span class="cov0" title="0">{
                session.OS = "iOS"
        }</span>

        // 检测浏览器
        <span class="cov8" title="1">if strings.Contains(ua, "chrome") &amp;&amp; !strings.Contains(ua, "edge") </span><span class="cov0" title="0">{
                session.Browser = "Chrome"
        }</span> else<span class="cov8" title="1"> if strings.Contains(ua, "firefox") </span><span class="cov0" title="0">{
                session.Browser = "Firefox"
        }</span> else<span class="cov8" title="1"> if strings.Contains(ua, "safari") &amp;&amp; !strings.Contains(ua, "chrome") </span><span class="cov0" title="0">{
                session.Browser = "Safari"
        }</span> else<span class="cov8" title="1"> if strings.Contains(ua, "edge") </span><span class="cov0" title="0">{
                session.Browser = "Edge"
        }</span> else<span class="cov8" title="1"> if strings.Contains(ua, "opera") </span><span class="cov0" title="0">{
                session.Browser = "Opera"
        }</span>

        // 检测平台
        <span class="cov8" title="1">if strings.Contains(ua, "mobile") || strings.Contains(ua, "android") || strings.Contains(ua, "iphone") </span><span class="cov0" title="0">{
                session.Platform = "mobile"
        }</span> else<span class="cov8" title="1"> {
                session.Platform = "web"
        }</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package verification

import (
        "database/sql"
        "fmt"
        "time"

        "trusioo_api/internal/auth/verification/entities"
        "trusioo_api/pkg/database"

        "github.com/jmoiron/sqlx"
)

type Repository struct {
        db *sqlx.DB
}

func NewRepository() *Repository <span class="cov0" title="0">{
        return &amp;Repository{
                db: database.DB,
        }
}</span>

// CreateVerification 创建验证码记录
func (r *Repository) CreateVerification(verification *entities.Verification) error <span class="cov0" title="0">{
        query := `
                INSERT INTO verifications (user_id, target, type, action, sent_at, code, is_used, expired_at, created_at)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
                RETURNING id
        `

        err := r.db.QueryRow(
                query,
                verification.UserID,
                verification.Target,
                verification.Type,
                verification.Action,
                verification.SentAt,
                verification.Code,
                verification.IsUsed,
                verification.ExpiredAt,
                verification.CreatedAt,
        ).Scan(&amp;verification.ID)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create verification: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetValidVerification 获取有效的验证码
func (r *Repository) GetValidVerification(target, verifyType, code string) (*entities.Verification, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, target, type, action, sent_at, code, is_used, expired_at, created_at
                FROM verifications
                WHERE target = $1 AND type = $2 AND code = $3 AND is_used = false AND expired_at &gt; NOW()
                ORDER BY created_at DESC
                LIMIT 1
        `

        verification := &amp;entities.Verification{}
        err := r.db.QueryRow(query, target, verifyType, code).Scan(
                &amp;verification.ID,
                &amp;verification.UserID,
                &amp;verification.Target,
                &amp;verification.Type,
                &amp;verification.Action,
                &amp;verification.SentAt,
                &amp;verification.Code,
                &amp;verification.IsUsed,
                &amp;verification.ExpiredAt,
                &amp;verification.CreatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get verification: %w", err)</span>
        }

        <span class="cov0" title="0">return verification, nil</span>
}

// MarkVerificationAsUsed 标记验证码为已使用
func (r *Repository) MarkVerificationAsUsed(id int64) error <span class="cov0" title="0">{
        query := `UPDATE verifications SET is_used = true WHERE id = $1`
        _, err := r.db.Exec(query, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to mark verification as used: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeleteExpiredVerifications 删除过期的验证码
func (r *Repository) DeleteExpiredVerifications() error <span class="cov0" title="0">{
        query := `DELETE FROM verifications WHERE expired_at &lt; NOW()`
        _, err := r.db.Exec(query)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete expired verifications: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetRecentVerification 获取最近发送的验证码（用于限制发送频率）
func (r *Repository) GetRecentVerification(target, verifyType string, duration time.Duration) (*entities.Verification, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, target, type, action, sent_at, code, is_used, expired_at, created_at
                FROM verifications
                WHERE target = $1 AND type = $2 AND sent_at &gt; $3
                ORDER BY sent_at DESC
                LIMIT 1
        `

        verification := &amp;entities.Verification{}
        limitTime := time.Now().Add(-duration)

        err := r.db.QueryRow(query, target, verifyType, limitTime).Scan(
                &amp;verification.ID,
                &amp;verification.UserID,
                &amp;verification.Target,
                &amp;verification.Type,
                &amp;verification.Action,
                &amp;verification.SentAt,
                &amp;verification.Code,
                &amp;verification.IsUsed,
                &amp;verification.ExpiredAt,
                &amp;verification.CreatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get recent verification: %w", err)</span>
        }

        <span class="cov0" title="0">return verification, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package verification

import (
        "crypto/rand"
        "database/sql"
        "fmt"
        "log"
        "math/big"
        "time"

        "trusioo_api/internal/auth/verification/dto"
        "trusioo_api/internal/auth/verification/entities"
        "trusioo_api/pkg/database"
)

type Service struct {
        repo *Repository
}

func NewService() *Service <span class="cov0" title="0">{
        return &amp;Service{
                repo: NewRepository(),
        }
}</span>

// checkUserExists 检查用户是否存在于数据库中
func (s *Service) checkUserExists(email, userType string) (bool, int64, error) <span class="cov0" title="0">{
        var userID int64
        var query string
        
        if userType == "admin" </span><span class="cov0" title="0">{
                query = "SELECT id FROM admins WHERE email = $1"
        }</span> else<span class="cov0" title="0"> {
                query = "SELECT id FROM users WHERE email = $1"
        }</span>
        
        <span class="cov0" title="0">err := database.DB.QueryRow(query, email).Scan(&amp;userID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return false, 0, nil // 用户不存在
                }</span>
                <span class="cov0" title="0">return false, 0, err</span> // 数据库错误
        }
        
        <span class="cov0" title="0">return true, userID, nil</span> // 用户存在
}

// activateUserAccount 激活用户账户
func (s *Service) activateUserAccount(email string) error <span class="cov0" title="0">{
        query := `
                UPDATE users 
                SET status = 'active', email_verified = true, updated_at = NOW()
                WHERE email = $1 AND status = 'inactive'
        `
        
        result, err := database.DB.Exec(query, email)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update user status: %w", err)
        }</span>
        
        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>
        
        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("user not found or already active")
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// SendVerificationCode 发送验证码
func (s *Service) SendVerificationCode(req *dto.SendVerificationRequest) (*dto.SendVerificationResponse, error) <span class="cov0" title="0">{


        // 生成6位数字验证码
        code, err := s.generateVerificationCode()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate verification code: %w", err)
        }</span>

        // 创建验证码记录
        <span class="cov0" title="0">now := time.Now()
        expiredAt := now.Add(10 * time.Minute) // 10分钟有效期

        verification := &amp;entities.Verification{
                Target:    req.Target,
                Type:      req.Type,
                Action:    entities.ActionEmailVerification,
                SentAt:    now,
                Code:      code,
                IsUsed:    false,
                ExpiredAt: expiredAt,
                CreatedAt: now,
        }

        err = s.repo.CreateVerification(verification)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save verification: %w", err)
        }</span>

        // 发送验证码邮件（这里暂时只记录日志，实际项目中需要集成邮件服务）
        <span class="cov0" title="0">err = s.sendEmail(req.Target, code, req.Type)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to send verification email: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;dto.SendVerificationResponse{
                Message:   "Verification code sent successfully",
                ExpiredAt: expiredAt.Format(time.RFC3339),
                Code:      code, // 仅用于测试环境
        }, nil</span>
}

// VerifyCode 验证验证码
func (s *Service) VerifyCode(req *dto.VerifyCodeRequest) (*dto.VerifyCodeResponse, error) <span class="cov0" title="0">{
        // 获取有效的验证码
        verification, err := s.repo.GetValidVerification(req.Target, req.Type, req.Code)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get verification: %w", err)
        }</span>

        <span class="cov0" title="0">if verification == nil </span><span class="cov0" title="0">{
                return &amp;dto.VerifyCodeResponse{
                        Message: "Invalid or expired verification code",
                        Valid:   false,
                }, nil
        }</span>

        // 标记验证码为已使用
        <span class="cov0" title="0">err = s.repo.MarkVerificationAsUsed(verification.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to mark verification as used: %w", err)
        }</span>


        <span class="cov0" title="0">return &amp;dto.VerifyCodeResponse{
                Message: "Verification code is valid",
                Valid:   true,
        }, nil</span>
}

// generateVerificationCode 生成6位数字验证码
func (s *Service) generateVerificationCode() (string, error) <span class="cov0" title="0">{
        code := ""
        for i := 0; i &lt; 6; i++ </span><span class="cov0" title="0">{
                n, err := rand.Int(rand.Reader, big.NewInt(10))
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">code += n.String()</span>
        }
        <span class="cov0" title="0">return code, nil</span>
}

// sendEmail 发送验证码邮件（模拟实现）
func (s *Service) sendEmail(target, code, verifyType string) error <span class="cov0" title="0">{
        // 将验证码打印到控制台，方便测试
        log.Printf("=== 验证码发送 ===")
        log.Printf("邮箱: %s", target)
        log.Printf("验证码: %s", code)
        log.Printf("类型: %s", verifyType)
        log.Printf("==================")

        // TODO: 集成真实的邮件服务
        // 例如：SendGrid, AWS SES, 阿里云邮件推送等

        // 模拟邮件发送可能的错误
        if target == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid email address")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CleanupExpiredVerifications 清理过期的验证码
func (s *Service) CleanupExpiredVerifications() error <span class="cov0" title="0">{
        return s.repo.DeleteExpiredVerifications()
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package middleware

import (
        "strings"

        "trusioo_api/internal/common"
        "trusioo_api/pkg/auth"

        "github.com/gin-gonic/gin"
)

// AuthMiddleware 用户认证中间件
func AuthMiddleware() gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                authHeader := c.GetHeader("Authorization")
                if authHeader == "" </span><span class="cov8" title="1">{
                        common.Unauthorized(c, "Authorization header required")
                        c.Abort()
                        return
                }</span>

                <span class="cov8" title="1">tokenParts := strings.Split(authHeader, " ")
                if len(tokenParts) != 2 || tokenParts[0] != "Bearer" </span><span class="cov8" title="1">{
                        common.Unauthorized(c, "Invalid authorization header format")
                        c.Abort()
                        return
                }</span>

                <span class="cov8" title="1">token := tokenParts[1]
                claims, err := auth.ValidateAccessToken(token)
                if err != nil </span><span class="cov8" title="1">{
                        common.Unauthorized(c, "Invalid or expired token")
                        c.Abort()
                        return
                }</span>

                // 检查用户类型
                <span class="cov8" title="1">if claims.UserType != "user" </span><span class="cov8" title="1">{
                        common.Forbidden(c, "Access denied")
                        c.Abort()
                        return
                }</span>

                // 将用户信息存储到上下文中
                <span class="cov8" title="1">c.Set("user_id", claims.UserID)
                c.Set("user_email", claims.Email)
                c.Set("user_role", claims.Role)
                c.Set("user_type", claims.UserType)

                c.Next()</span>
        }
}

// OptionalAuth 可选认证中间件
// 如果提供了token则验证，如果没有提供则不验证，继续执行
func OptionalAuth() gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                authHeader := c.GetHeader("Authorization")
                if authHeader == "" </span><span class="cov8" title="1">{
                        // 没有提供认证头，继续执行
                        c.Next()
                        return
                }</span>

                <span class="cov8" title="1">tokenParts := strings.Split(authHeader, " ")
                if len(tokenParts) != 2 || tokenParts[0] != "Bearer" </span><span class="cov8" title="1">{
                        // 认证头格式不正确，但不阻止执行
                        c.Next()
                        return
                }</span>

                <span class="cov8" title="1">token := tokenParts[1]
                claims, err := auth.ValidateAccessToken(token)
                if err != nil </span><span class="cov8" title="1">{
                        // token无效，但不阻止执行
                        c.Next()
                        return
                }</span>

                // token有效，将用户信息存储到上下文中
                <span class="cov8" title="1">c.Set("user_id", claims.UserID)
                c.Set("user_email", claims.Email)
                c.Set("user_role", claims.Role)
                c.Set("user_type", claims.UserType)

                c.Next()</span>
        }
}

// AdminAuthMiddleware 管理员认证中间件
func AdminAuthMiddleware() gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                authHeader := c.GetHeader("Authorization")
                if authHeader == "" </span><span class="cov8" title="1">{
                        common.Unauthorized(c, "Authorization header required")
                        c.Abort()
                        return
                }</span>

                <span class="cov8" title="1">tokenParts := strings.Split(authHeader, " ")
                if len(tokenParts) != 2 || tokenParts[0] != "Bearer" </span><span class="cov0" title="0">{
                        common.Unauthorized(c, "Invalid authorization header format")
                        c.Abort()
                        return
                }</span>

                <span class="cov8" title="1">token := tokenParts[1]
                claims, err := auth.ValidateAccessToken(token)
                if err != nil </span><span class="cov0" title="0">{
                        common.Unauthorized(c, "Invalid or expired token")
                        c.Abort()
                        return
                }</span>

                // 检查用户类型
                <span class="cov8" title="1">if claims.UserType != "admin" </span><span class="cov8" title="1">{
                        common.Forbidden(c, "Admin access required")
                        c.Abort()
                        return
                }</span>

                // 将管理员信息存储到上下文中
                <span class="cov8" title="1">c.Set("user_id", claims.UserID)
                c.Set("user_email", claims.Email)
                c.Set("user_role", claims.Role)
                c.Set("user_type", claims.UserType)

                c.Next()</span>
        }
}

// SuperAdminMiddleware 超级管理员认证中间件
func SuperAdminMiddleware() gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                authHeader := c.GetHeader("Authorization")
                if authHeader == "" </span><span class="cov0" title="0">{
                        common.Unauthorized(c, "Authorization header required")
                        c.Abort()
                        return
                }</span>

                <span class="cov8" title="1">tokenParts := strings.Split(authHeader, " ")
                if len(tokenParts) != 2 || tokenParts[0] != "Bearer" </span><span class="cov0" title="0">{
                        common.Unauthorized(c, "Invalid authorization header format")
                        c.Abort()
                        return
                }</span>

                <span class="cov8" title="1">token := tokenParts[1]
                claims, err := auth.ValidateAccessToken(token)
                if err != nil </span><span class="cov0" title="0">{
                        common.Unauthorized(c, "Invalid or expired token")
                        c.Abort()
                        return
                }</span>

                // 检查用户类型和角色
                <span class="cov8" title="1">if claims.UserType != "admin" || claims.Role != "super_admin" </span><span class="cov8" title="1">{
                        common.Forbidden(c, "Super admin access required")
                        c.Abort()
                        return
                }</span>

                // 将管理员信息存储到上下文中
                <span class="cov8" title="1">c.Set("user_id", claims.UserID)
                c.Set("user_email", claims.Email)
                c.Set("user_role", claims.Role)
                c.Set("user_type", claims.UserType)

                c.Next()</span>
        }
}</pre>
		
		<pre class="file" id="file13" style="display: none">package middleware

import (
        "bytes"
        "io"
        "mime/multipart"
        "net/http"

        "github.com/gin-gonic/gin"
        "trusioo_api/internal/common"
        "trusioo_api/pkg/imageprocessor"
)

type ImageProcessingConfig struct {
        MaxWidth         uint
        MaxHeight        uint
        Quality          int
        AutoOptimize     bool
        CreateThumbnails bool
        ThumbnailSizes   []ThumbnailSize
}

type ThumbnailSize struct {
        Name   string
        Width  uint
        Height uint
}

func ImageProcessingMiddleware(config ImageProcessingConfig) gin.HandlerFunc <span class="cov0" title="0">{
        processor := imageprocessor.NewProcessor()

        return func(c *gin.Context) </span><span class="cov0" title="0">{
                if c.Request.Method == "POST" &amp;&amp; c.ContentType() == "multipart/form-data" </span><span class="cov0" title="0">{
                        err := c.Request.ParseMultipartForm(32 &lt;&lt; 20) // 32 MB
                        if err != nil </span><span class="cov0" title="0">{
                                c.JSON(http.StatusBadRequest, common.ErrorResponse{
                                        Error:   "FORM_PARSE_ERROR",
                                        Message: "Failed to parse multipart form",
                                })
                                c.Abort()
                                return
                        }</span>

                        <span class="cov0" title="0">form := c.Request.MultipartForm
                        if form == nil || form.File == nil </span><span class="cov0" title="0">{
                                c.Next()
                                return
                        }</span>

                        // Process each file field
                        <span class="cov0" title="0">for fieldName, fileHeaders := range form.File </span><span class="cov0" title="0">{
                                if fieldName != "file" &amp;&amp; fieldName != "image" </span><span class="cov0" title="0">{
                                        continue</span> // Only process specific file fields
                                }

                                <span class="cov0" title="0">for i, fileHeader := range fileHeaders </span><span class="cov0" title="0">{
                                        if !imageprocessor.IsImageFile(fileHeader.Filename) </span><span class="cov0" title="0">{
                                                continue</span> // Skip non-image files
                                        }

                                        // Get image dimensions
                                        <span class="cov0" title="0">width, height, err := imageprocessor.GetImageDimensions(fileHeader)
                                        if err != nil </span><span class="cov0" title="0">{
                                                c.JSON(http.StatusBadRequest, common.ErrorResponse{
                                                        Error:   "INVALID_IMAGE",
                                                        Message: "Failed to read image dimensions",
                                                })
                                                c.Abort()
                                                return
                                        }</span>

                                        // Check if processing is needed
                                        <span class="cov0" title="0">needsProcessing := config.AutoOptimize ||
                                                (config.MaxWidth &gt; 0 &amp;&amp; uint(width) &gt; config.MaxWidth) ||
                                                (config.MaxHeight &gt; 0 &amp;&amp; uint(height) &gt; config.MaxHeight)

                                        if needsProcessing </span><span class="cov0" title="0">{
                                                // Process the image
                                                options := &amp;imageprocessor.ProcessorOptions{
                                                        MaxWidth:  config.MaxWidth,
                                                        MaxHeight: config.MaxHeight,
                                                        Quality:   config.Quality,
                                                        Compress:  config.AutoOptimize,
                                                }

                                                processedBuffer, contentType, err := processor.ProcessImage(fileHeader, options)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        c.JSON(http.StatusInternalServerError, common.ErrorResponse{
                                                                Error:   "IMAGE_PROCESSING_ERROR",
                                                                Message: "Failed to process image",
                                                        })
                                                        c.Abort()
                                                        return
                                                }</span>

                                                // Replace the original file with processed version
                                                <span class="cov0" title="0">newFileHeader := &amp;multipart.FileHeader{
                                                        Filename: fileHeader.Filename,
                                                        Header:   make(map[string][]string),
                                                        Size:     int64(processedBuffer.Len()),
                                                }
                                                newFileHeader.Header.Set("Content-Type", contentType)

                                                // Create a new file reader from processed buffer
                                                processedFile := &amp;processedFileReader{
                                                        buffer: processedBuffer,
                                                        pos:    0,
                                                }

                                                // Store the processed file in context for later use
                                                c.Set("processed_file_"+fieldName, processedFile)
                                                c.Set("processed_file_header_"+fieldName, newFileHeader)

                                                // Replace in form
                                                fileHeaders[i] = newFileHeader</span>
                                        }

                                        // Create thumbnails if requested
                                        <span class="cov0" title="0">if config.CreateThumbnails &amp;&amp; len(config.ThumbnailSizes) &gt; 0 </span><span class="cov0" title="0">{
                                                thumbnails := make(map[string]*bytes.Buffer)

                                                for _, size := range config.ThumbnailSizes </span><span class="cov0" title="0">{
                                                        thumbBuffer, _, err := processor.CreateThumbnail(fileHeader, size.Width, size.Height)
                                                        if err == nil </span><span class="cov0" title="0">{
                                                                thumbnails[size.Name] = thumbBuffer
                                                        }</span>
                                                }

                                                <span class="cov0" title="0">if len(thumbnails) &gt; 0 </span><span class="cov0" title="0">{
                                                        c.Set("thumbnails_"+fieldName, thumbnails)
                                                }</span>
                                        }
                                }
                        }
                }

                <span class="cov0" title="0">c.Next()</span>
        }
}

type processedFileReader struct {
        buffer *bytes.Buffer
        pos    int64
}

func (r *processedFileReader) Read(p []byte) (int, error) <span class="cov0" title="0">{
        if r.pos &gt;= int64(r.buffer.Len()) </span><span class="cov0" title="0">{
                return 0, io.EOF
        }</span>

        <span class="cov0" title="0">n := copy(p, r.buffer.Bytes()[r.pos:])
        r.pos += int64(n)
        return n, nil</span>
}

func (r *processedFileReader) Seek(offset int64, whence int) (int64, error) <span class="cov0" title="0">{
        switch whence </span>{
        case io.SeekStart:<span class="cov0" title="0">
                r.pos = offset</span>
        case io.SeekCurrent:<span class="cov0" title="0">
                r.pos += offset</span>
        case io.SeekEnd:<span class="cov0" title="0">
                r.pos = int64(r.buffer.Len()) + offset</span>
        }

        <span class="cov0" title="0">if r.pos &lt; 0 </span><span class="cov0" title="0">{
                r.pos = 0
        }</span>
        <span class="cov0" title="0">if r.pos &gt; int64(r.buffer.Len()) </span><span class="cov0" title="0">{
                r.pos = int64(r.buffer.Len())
        }</span>

        <span class="cov0" title="0">return r.pos, nil</span>
}

func (r *processedFileReader) Close() error <span class="cov0" title="0">{
        return nil
}</span>

// Helper function to get processed file from context
func GetProcessedFile(c *gin.Context, fieldName string) (multipart.File, *multipart.FileHeader, bool) <span class="cov0" title="0">{
        if file, exists := c.Get("processed_file_" + fieldName); exists </span><span class="cov0" title="0">{
                if header, headerExists := c.Get("processed_file_header_" + fieldName); headerExists </span><span class="cov0" title="0">{
                        if f, ok := file.(multipart.File); ok </span><span class="cov0" title="0">{
                                if h, ok := header.(*multipart.FileHeader); ok </span><span class="cov0" title="0">{
                                        return f, h, true
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return nil, nil, false</span>
}

// Helper function to get thumbnails from context
func GetThumbnails(c *gin.Context, fieldName string) (map[string]*bytes.Buffer, bool) <span class="cov0" title="0">{
        if thumbnails, exists := c.Get("thumbnails_" + fieldName); exists </span><span class="cov0" title="0">{
                if thumbs, ok := thumbnails.(map[string]*bytes.Buffer); ok </span><span class="cov0" title="0">{
                        return thumbs, true
                }</span>
        }
        <span class="cov0" title="0">return nil, false</span>
}</pre>
		
		<pre class="file" id="file14" style="display: none">package middleware

import (
        "net/http"
        "sync"
        "time"

        "trusioo_api/internal/common"

        "github.com/gin-gonic/gin"
)

// RateLimiter 简单的内存率限制器
type RateLimiter struct {
        visitors map[string]*Visitor
        mutex    sync.RWMutex
}

type Visitor struct {
        limiter  *TokenBucket
        lastSeen time.Time
}

type TokenBucket struct {
        tokens    int
        capacity  int
        rate      time.Duration
        lastRefill time.Time
        mutex     sync.Mutex
}

// NewTokenBucket 创建新的令牌桶
func NewTokenBucket(capacity int, rate time.Duration) *TokenBucket <span class="cov0" title="0">{
        return &amp;TokenBucket{
                tokens:     capacity,
                capacity:   capacity,
                rate:       rate,
                lastRefill: time.Now(),
        }
}</span>

// Allow 检查是否允许请求
func (tb *TokenBucket) Allow() bool <span class="cov0" title="0">{
        tb.mutex.Lock()
        defer tb.mutex.Unlock()

        now := time.Now()
        elapsed := now.Sub(tb.lastRefill)
        
        // 根据时间间隔添加令牌
        tokensToAdd := int(elapsed / tb.rate)
        if tokensToAdd &gt; 0 </span><span class="cov0" title="0">{
                tb.tokens += tokensToAdd
                if tb.tokens &gt; tb.capacity </span><span class="cov0" title="0">{
                        tb.tokens = tb.capacity
                }</span>
                <span class="cov0" title="0">tb.lastRefill = now</span>
        }

        <span class="cov0" title="0">if tb.tokens &gt; 0 </span><span class="cov0" title="0">{
                tb.tokens--
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// NewRateLimiter 创建新的速率限制器
func NewRateLimiter() *RateLimiter <span class="cov0" title="0">{
        rl := &amp;RateLimiter{
                visitors: make(map[string]*Visitor),
        }

        // 启动清理 goroutine
        go rl.cleanupVisitors()
        return rl
}</span>

// cleanupVisitors 清理过期的访问者
func (rl *RateLimiter) cleanupVisitors() <span class="cov0" title="0">{
        ticker := time.NewTicker(1 * time.Minute)
        defer ticker.Stop()

        for range ticker.C </span><span class="cov0" title="0">{
                rl.mutex.Lock()
                for ip, visitor := range rl.visitors </span><span class="cov0" title="0">{
                        if time.Since(visitor.lastSeen) &gt; 3*time.Minute </span><span class="cov0" title="0">{
                                delete(rl.visitors, ip)
                        }</span>
                }
                <span class="cov0" title="0">rl.mutex.Unlock()</span>
        }
}

// getVisitor 获取或创建访问者
func (rl *RateLimiter) getVisitor(ip string) *Visitor <span class="cov0" title="0">{
        rl.mutex.Lock()
        defer rl.mutex.Unlock()

        visitor, exists := rl.visitors[ip]
        if !exists </span><span class="cov0" title="0">{
                // 创建新访问者: 每分钟100个请求
                visitor = &amp;Visitor{
                        limiter: NewTokenBucket(100, time.Minute/100),
                }
                rl.visitors[ip] = visitor
        }</span>

        <span class="cov0" title="0">visitor.lastSeen = time.Now()
        return visitor</span>
}

// RateLimitMiddleware 速率限制中间件
func RateLimitMiddleware(rateLimiter *RateLimiter) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                ip := c.ClientIP()
                visitor := rateLimiter.getVisitor(ip)

                if !visitor.limiter.Allow() </span><span class="cov0" title="0">{
                        c.JSON(http.StatusTooManyRequests, common.Response{
                                Code:    429,
                                Message: "Too many requests. Please try again later.",
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

// AuthRateLimitMiddleware 认证接口的严格速率限制
func AuthRateLimitMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        limiter := NewRateLimiter()
        
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                ip := c.ClientIP()
                
                // 为认证相关接口创建更严格的限制
                visitor, exists := limiter.visitors[ip]
                if !exists </span><span class="cov0" title="0">{
                        // 每分钟只允许10次认证请求
                        visitor = &amp;Visitor{
                                limiter: NewTokenBucket(10, time.Minute/10),
                        }
                        limiter.visitors[ip] = visitor
                }</span>
                
                <span class="cov0" title="0">visitor.lastSeen = time.Now()

                if !visitor.limiter.Allow() </span><span class="cov0" title="0">{
                        c.JSON(http.StatusTooManyRequests, common.Response{
                                Code:    429,
                                Message: "Too many authentication attempts. Please try again later.",
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}</pre>
		
		<pre class="file" id="file15" style="display: none">package middleware

import (
        "trusioo_api/pkg/logger"
        "trusioo_api/pkg/utils"

        "github.com/gin-gonic/gin"
        "github.com/sirupsen/logrus"
)

// RequestIDMiddleware 请求ID中间件
func RequestIDMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // 从请求头获取现有的请求ID，或生成新的
                requestID := c.GetHeader("X-Request-ID")
                if requestID == "" </span><span class="cov0" title="0">{
                        requestID = utils.GenerateUUID()
                }</span>

                // 设置请求ID到上下文和响应头
                <span class="cov0" title="0">c.Set("request_id", requestID)
                c.Header("X-Request-ID", requestID)

                c.Next()</span>
        }
}

// LoggingMiddleware 请求日志中间件
func LoggingMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return gin.LoggerWithFormatter(func(param gin.LogFormatterParams) string </span><span class="cov0" title="0">{
                requestID, _ := param.Keys["request_id"].(string)
                
                // 使用结构化日志记录请求
                logger.WithFields(logrus.Fields{
                        "request_id":   requestID,
                        "method":       param.Method,
                        "path":         param.Path,
                        "status":       param.StatusCode,
                        "latency":      param.Latency.String(),
                        "ip":           param.ClientIP,
                        "user_agent":   param.Request.UserAgent(),
                        "error":        param.ErrorMessage,
                        "body_size":    param.BodySize,
                }).Info("HTTP Request")

                return ""
        }</span>)
}

// RecoveryMiddleware 自定义恢复中间件
func RecoveryMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return gin.CustomRecovery(func(c *gin.Context, recovered interface{}) </span><span class="cov0" title="0">{
                requestID, _ := c.Get("request_id")
                
                logger.WithFields(logrus.Fields{
                        "request_id": requestID,
                        "method":     c.Request.Method,
                        "path":       c.Request.URL.Path,
                        "ip":         c.ClientIP,
                        "panic":      recovered,
                }).Error("Panic recovered")

                c.JSON(500, gin.H{
                        "code":       500,
                        "message":    "Internal server error",
                        "request_id": requestID,
                })
        }</span>)
}

// CorrelationMiddleware 关联ID中间件（用于微服务追踪）
func CorrelationMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // 从请求头获取关联ID
                correlationID := c.GetHeader("X-Correlation-ID")
                if correlationID == "" </span><span class="cov0" title="0">{
                        correlationID = utils.GenerateUUID()
                }</span>

                // 设置到上下文和响应头
                <span class="cov0" title="0">c.Set("correlation_id", correlationID)
                c.Header("X-Correlation-ID", correlationID)

                c.Next()</span>
        }
}</pre>
		
		<pre class="file" id="file16" style="display: none">package middleware

import (
        "context"
        "net/http"
        "strings"
        "time"

        "trusioo_api/config"
        "trusioo_api/internal/common"

        "github.com/gin-gonic/gin"
)

// SecurityHeadersMiddleware 安全头中间件
func SecurityHeadersMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // 内容类型嗅探保护
                c.Header("X-Content-Type-Options", "nosniff")
                
                // 点击劫持保护
                c.Header("X-Frame-Options", "DENY")
                
                // XSS 保护
                c.Header("X-XSS-Protection", "1; mode=block")
                
                // HTTPS 严格传输安全
                if c.Request.TLS != nil || c.GetHeader("X-Forwarded-Proto") == "https" </span><span class="cov0" title="0">{
                        c.Header("Strict-Transport-Security", "max-age=31536000; includeSubDomains; preload")
                }</span>
                
                // 内容安全策略
                <span class="cov0" title="0">csp := "default-src 'self'; " +
                        "script-src 'self' 'unsafe-inline'; " +
                        "style-src 'self' 'unsafe-inline'; " +
                        "img-src 'self' data: https:; " +
                        "font-src 'self'; " +
                        "connect-src 'self'; " +
                        "media-src 'self'; " +
                        "object-src 'none'; " +
                        "child-src 'none'; " +
                        "worker-src 'none'; " +
                        "frame-ancestors 'none'; " +
                        "form-action 'self'; " +
                        "base-uri 'self'"
                c.Header("Content-Security-Policy", csp)
                
                // 引用来源策略
                c.Header("Referrer-Policy", "strict-origin-when-cross-origin")
                
                // 权限策略
                permissions := "geolocation=(), microphone=(), camera=(), " +
                        "payment=(), usb=(), magnetometer=(), gyroscope=(), " +
                        "speaker=(), vibrate=(), fullscreen=(self)"
                c.Header("Permissions-Policy", permissions)
                
                // 移除服务器标识
                c.Header("Server", "")
                
                // 缓存控制（对于敏感数据）
                if strings.Contains(c.Request.URL.Path, "/api/auth/") ||
                   strings.Contains(c.Request.URL.Path, "/api/admin/") </span><span class="cov0" title="0">{
                        c.Header("Cache-Control", "no-store, no-cache, must-revalidate, private")
                        c.Header("Pragma", "no-cache")
                        c.Header("Expires", "0")
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

// CORSMiddleware CORS 中间件
func CORSMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                cfg := config.AppConfig.CORS
                
                origin := c.Request.Header.Get("Origin")
                
                // 如果允许所有来源
                if cfg.AllowAll </span><span class="cov0" title="0">{
                        c.Header("Access-Control-Allow-Origin", "*")
                }</span> else<span class="cov0" title="0"> {
                        // 检查是否在允许列表中
                        allowed := false
                        for _, allowedOrigin := range cfg.Origins </span><span class="cov0" title="0">{
                                if origin == allowedOrigin </span><span class="cov0" title="0">{
                                        allowed = true
                                        break</span>
                                }
                        }
                        
                        <span class="cov0" title="0">if allowed </span><span class="cov0" title="0">{
                                c.Header("Access-Control-Allow-Origin", origin)
                        }</span>
                }
                
                <span class="cov0" title="0">c.Header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, PATCH, OPTIONS")
                c.Header("Access-Control-Allow-Headers", 
                        "Origin, Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, " +
                        "Authorization, X-Requested-With, X-Request-ID, X-Correlation-ID")
                c.Header("Access-Control-Expose-Headers", "X-Request-ID, X-Correlation-ID")
                c.Header("Access-Control-Allow-Credentials", "true")
                c.Header("Access-Control-Max-Age", "86400") // 24小时
                
                // 处理预检请求
                if c.Request.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        c.AbortWithStatus(http.StatusNoContent)
                        return
                }</span>
                
                <span class="cov0" title="0">c.Next()</span>
        }
}

// HTTPSRedirectMiddleware HTTPS 重定向中间件
func HTTPSRedirectMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // 只在生产环境强制 HTTPS
                if config.AppConfig.Server.Env == "production" </span><span class="cov0" title="0">{
                        if c.Request.Header.Get("X-Forwarded-Proto") != "https" </span><span class="cov0" title="0">{
                                url := "https://" + c.Request.Host + c.Request.RequestURI
                                c.Redirect(http.StatusMovedPermanently, url)
                                c.Abort()
                                return
                        }</span>
                }
                <span class="cov0" title="0">c.Next()</span>
        }
}

// ContentTypeValidationMiddleware 内容类型验证中间件
func ContentTypeValidationMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // 对于 POST, PUT, PATCH 请求，验证内容类型
                if c.Request.Method == "POST" || c.Request.Method == "PUT" || c.Request.Method == "PATCH" </span><span class="cov0" title="0">{
                        contentType := c.GetHeader("Content-Type")
                        
                        // 跳过文件上传
                        if strings.Contains(contentType, "multipart/form-data") </span><span class="cov0" title="0">{
                                c.Next()
                                return
                        }</span>
                        
                        // 要求 JSON 内容类型
                        <span class="cov0" title="0">if !strings.Contains(contentType, "application/json") </span><span class="cov0" title="0">{
                                common.ValidationError(c, "Content-Type must be application/json")
                                c.Abort()
                                return
                        }</span>
                }
                
                <span class="cov0" title="0">c.Next()</span>
        }
}

// RequestSizeLimit 请求大小限制中间件
func RequestSizeLimitMiddleware(maxSize int64) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                if c.Request.ContentLength &gt; maxSize </span><span class="cov0" title="0">{
                        c.JSON(http.StatusRequestEntityTooLarge, common.Response{
                                Code:    413,
                                Message: "Request entity too large",
                        })
                        c.Abort()
                        return
                }</span>
                
                <span class="cov0" title="0">c.Request.Body = http.MaxBytesReader(c.Writer, c.Request.Body, maxSize)
                c.Next()</span>
        }
}

// TimeoutMiddleware 请求超时中间件
func TimeoutMiddleware(timeout time.Duration) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // 创建带超时的上下文
                ctx, cancel := context.WithTimeout(c.Request.Context(), timeout)
                defer cancel()
                
                // 替换请求上下文
                c.Request = c.Request.WithContext(ctx)
                
                // 创建一个通道来接收处理完成信号
                done := make(chan bool, 1)
                
                // 在 goroutine 中处理请求
                go func() </span><span class="cov0" title="0">{
                        c.Next()
                        done &lt;- true
                }</span>()
                
                // 等待处理完成或超时
                <span class="cov0" title="0">select </span>{
                case &lt;-done:<span class="cov0" title="0">
                        // 请求正常完成
                        return</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        // 请求超时
                        c.JSON(http.StatusRequestTimeout, common.Response{
                                Code:    408,
                                Message: "Request timeout",
                        })
                        c.Abort()
                        return</span>
                }
        }
}

// IPWhitelistMiddleware IP 白名单中间件
func IPWhitelistMiddleware(whitelist []string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                if len(whitelist) == 0 </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>
                
                <span class="cov0" title="0">clientIP := c.ClientIP()
                allowed := false
                
                for _, ip := range whitelist </span><span class="cov0" title="0">{
                        if clientIP == ip </span><span class="cov0" title="0">{
                                allowed = true
                                break</span>
                        }
                }
                
                <span class="cov0" title="0">if !allowed </span><span class="cov0" title="0">{
                        c.JSON(http.StatusForbidden, common.Response{
                                Code:    403,
                                Message: "Access denied from your IP address",
                        })
                        c.Abort()
                        return
                }</span>
                
                <span class="cov0" title="0">c.Next()</span>
        }
}</pre>
		
		<pre class="file" id="file17" style="display: none">package middleware

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "regexp"
        "strings"

        "trusioo_api/internal/common"

        "github.com/gin-gonic/gin"
)

// ValidationRule 验证规则
type ValidationRule struct {
        Field     string
        Required  bool
        MinLength int
        MaxLength int
        Pattern   *regexp.Regexp
        Custom    func(interface{}) error
}

// Validator 验证器
type Validator struct {
        rules []ValidationRule
}

// NewValidator 创建新验证器
func NewValidator() *Validator <span class="cov0" title="0">{
        return &amp;Validator{
                rules: make([]ValidationRule, 0),
        }
}</span>

// AddRule 添加验证规则
func (v *Validator) AddRule(rule ValidationRule) *Validator <span class="cov0" title="0">{
        v.rules = append(v.rules, rule)
        return v
}</span>

// Validate 执行验证
func (v *Validator) Validate(data map[string]interface{}) []string <span class="cov0" title="0">{
        var errors []string

        for _, rule := range v.rules </span><span class="cov0" title="0">{
                value, exists := data[rule.Field]

                // 检查必填字段
                if rule.Required &amp;&amp; (!exists || value == nil || value == "") </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Sprintf("%s is required", rule.Field))
                        continue</span>
                }

                // 如果字段不存在且不是必填，跳过其他验证
                <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                        continue</span>
                }

                // 转换为字符串进行验证
                <span class="cov0" title="0">strValue, ok := value.(string)
                if !ok </span><span class="cov0" title="0">{
                        if value != nil </span><span class="cov0" title="0">{
                                strValue = fmt.Sprintf("%v", value)
                        }</span>
                }

                // 长度验证
                <span class="cov0" title="0">if rule.MinLength &gt; 0 &amp;&amp; len(strValue) &lt; rule.MinLength </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Sprintf("%s must be at least %d characters", rule.Field, rule.MinLength))
                }</span>

                <span class="cov0" title="0">if rule.MaxLength &gt; 0 &amp;&amp; len(strValue) &gt; rule.MaxLength </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Sprintf("%s must not exceed %d characters", rule.Field, rule.MaxLength))
                }</span>

                // 正则验证
                <span class="cov0" title="0">if rule.Pattern != nil &amp;&amp; strValue != "" &amp;&amp; !rule.Pattern.MatchString(strValue) </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Sprintf("%s format is invalid", rule.Field))
                }</span>

                // 自定义验证
                <span class="cov0" title="0">if rule.Custom != nil </span><span class="cov0" title="0">{
                        if err := rule.Custom(value); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, err.Error())
                        }</span>
                }
        }

        <span class="cov0" title="0">return errors</span>
}

// RequestValidationMiddleware 请求验证中间件
func RequestValidationMiddleware(validator *Validator) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // 只验证 JSON 请求
                if !strings.Contains(c.GetHeader("Content-Type"), "application/json") </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                // 读取请求体
                <span class="cov0" title="0">body, err := io.ReadAll(c.Request.Body)
                if err != nil </span><span class="cov0" title="0">{
                        common.ValidationError(c, "Failed to read request body")
                        c.Abort()
                        return
                }</span>

                // 恢复请求体供后续使用
                <span class="cov0" title="0">c.Request.Body = io.NopCloser(bytes.NewBuffer(body))

                // 解析 JSON
                var data map[string]interface{}
                if err := json.Unmarshal(body, &amp;data); err != nil </span><span class="cov0" title="0">{
                        common.ValidationError(c, "Invalid JSON format")
                        c.Abort()
                        return
                }</span>

                // 执行验证
                <span class="cov0" title="0">errors := validator.Validate(data)
                if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                        common.ValidationError(c, strings.Join(errors, "; "))
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

// 常用验证规则
var (
        EmailPattern    = regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
        PhonePattern    = regexp.MustCompile(`^(\+\d{1,3}[- ]?)?\d{10,11}$`)
        PasswordPattern = regexp.MustCompile(`^[a-zA-Z\d@$!%*?&amp;]{8,}$`)  // 简化的密码模式
        UUIDPattern     = regexp.MustCompile(`^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$`)
)

// 预定义验证器

// LoginValidator 登录验证器
func LoginValidator() *Validator <span class="cov0" title="0">{
        return NewValidator().
                AddRule(ValidationRule{
                        Field:    "email",
                        Required: true,
                        Pattern:  EmailPattern,
                }).
                AddRule(ValidationRule{
                        Field:     "password",
                        Required:  true,
                        MinLength: 1,
                })
}</span>

// RegisterValidator 注册验证器
func RegisterValidator() *Validator <span class="cov0" title="0">{
        return NewValidator().
                AddRule(ValidationRule{
                        Field:    "email",
                        Required: true,
                        Pattern:  EmailPattern,
                }).
                AddRule(ValidationRule{
                        Field:     "password",
                        Required:  true,
                        MinLength: 8,
                        Pattern:   PasswordPattern,
                }).
                AddRule(ValidationRule{
                        Field:     "name",
                        Required:  true,
                        MinLength: 2,
                        MaxLength: 50,
                })
}</span>

// VerificationCodeValidator 验证码验证器
func VerificationCodeValidator() *Validator <span class="cov0" title="0">{
        return NewValidator().
                AddRule(ValidationRule{
                        Field:    "email",
                        Required: true,
                        Pattern:  EmailPattern,
                }).
                AddRule(ValidationRule{
                        Field:     "code",
                        Required:  true,
                        MinLength: 4,
                        MaxLength: 8,
                })
}</span>

</pre>
		
		<pre class="file" id="file18" style="display: none">package auth

import (
        "fmt"
        "time"

        "trusioo_api/config"

        "github.com/golang-jwt/jwt/v5"
)

type Claims struct {
        UserID   int64  `json:"user_id"`
        Email    string `json:"email"`
        Role     string `json:"role"`
        UserType string `json:"user_type"` // "user" or "admin"
        jwt.RegisteredClaims
}

func GenerateAccessToken(userID int64, email, role, userType string) (string, error) <span class="cov8" title="1">{
        claims := Claims{
                UserID:   userID,
                Email:    email,
                Role:     role,
                UserType: userType,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(time.Now().Add(time.Duration(config.AppConfig.JWT.AccessExpire) * time.Second)),
                        IssuedAt:  jwt.NewNumericDate(time.Now()),
                        NotBefore: jwt.NewNumericDate(time.Now()),
                        Issuer:    "trusioo_api",
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString([]byte(config.AppConfig.JWT.Secret))
}</span>

func GenerateRefreshToken(userID int64, email, role, userType string) (string, error) <span class="cov8" title="1">{
        claims := Claims{
                UserID:   userID,
                Email:    email,
                Role:     role,
                UserType: userType,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(time.Now().Add(time.Duration(config.AppConfig.JWT.RefreshExpire) * time.Second)),
                        IssuedAt:  jwt.NewNumericDate(time.Now()),
                        NotBefore: jwt.NewNumericDate(time.Now()),
                        Issuer:    "trusioo_api",
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString([]byte(config.AppConfig.JWT.RefreshSecret))
}</span>

func ValidateAccessToken(tokenString string) (*Claims, error) <span class="cov8" title="1">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov8" title="1">return []byte(config.AppConfig.JWT.Secret), nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">claims, ok := token.Claims.(*Claims)
        if !ok || !token.Valid </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid token")
        }</span>

        <span class="cov8" title="1">return claims, nil</span>
}

func ValidateRefreshToken(tokenString string) (*Claims, error) <span class="cov8" title="1">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov8" title="1">return []byte(config.AppConfig.JWT.RefreshSecret), nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">claims, ok := token.Claims.(*Claims)
        if !ok || !token.Valid </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid token")
        }</span>

        <span class="cov8" title="1">return claims, nil</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
